// Generated by dts-bundle-generator v8.0.1

import { AxiosRequestConfig, Method } from 'axios';

export interface Metadata {
	color?: string;
	x?: string | number;
	y?: string | number;
	label?: string;
	file?: {
		url: string;
		md5: string;
		path: string;
	};
	icon?: string;
	fixed_position?: {
		[key: string]: {
			color: string;
			icon: string;
			value: string;
			x: string;
			y: string;
		};
	};
	sentValues?: {
		label: string;
		value: string | number | boolean;
	}[];
	old_value?: string | number | boolean;
	[key: string]: any;
}
export type LocationGeoJSON = {
	type: "Point";
	coordinates: number[];
};
export type LocationLatLng = {
	lat: number;
	lng: number;
};
/**
 * Type for the data returned from the API.
 */
export interface Data {
	/**
	 * Data ID.
	 */
	id: string;
	/**
	 * ID of the device holding the data.
	 */
	device: GenericID;
	/**
	 * ID of the device holding the data.
	 *
	 * @deprecated Deprecating this in favor of `device`.
	 */
	origin?: GenericID;
	/**
	 * Name of the variable for the data.
	 */
	variable: string;
	/**
	 * Data value.
	 */
	value?: string | number | boolean;
	/**
	 * Group for the data. Used for grouping different data values.
	 */
	group?: string;
	/**
	 * Series for the data. Used for grouping different data values.
	 *
	 * @deprecated Deprecating this in favor of `group`.
	 */
	serie?: string;
	/**
	 * Unit for the data value.
	 */
	unit?: string;
	/**
	 * Location for the data value.
	 */
	location?: LocationGeoJSON;
	/**
	 * Metadata for the data value.
	 */
	metadata?: Metadata;
	/**
	 * Timestamp for the data value.
	 */
	time: Date;
	/**
	 * Timestamp for the data value. Determined by the API.
	 */
	created_at?: Date;
}
/**
 * Type for creating data and sending it to the API.
 */
export type DataCreate = Required<Pick<Data, "variable">> & Partial<Omit<Data, "id" | "device" | "origin" | "location" | "time" | "created_at"> & {
	/**
	 * Location for the data value.
	 */
	location: LocationGeoJSON | LocationLatLng | null;
	/**
	 * Timestamp for the data value.
	 */
	time: string | Date;
}>;
/**
 * Type for editing data and sending it to the API.
 */
export type DataEdit = Required<Pick<Data, "id">> & Partial<Pick<DataCreate, "value" | "group" | "serie" | "unit" | "metadata" | "time" | "location">>;
export interface TagsObj {
	key: string;
	value: string;
}
export type RecursivePartial<T> = {
	[P in keyof T]?: T[P] extends (infer U)[] ? RecursivePartial<U>[] : T[P] extends object ? RecursivePartial<T[P]> : T[P];
};
export interface Query<T, U> {
	/**
	 * Page of list starting from 1
	 */
	page?: number;
	/**
	 * Amount of items will return.
	 */
	amount?: number;
	/**
	 *  Array of field names.
	 */
	fields?: (keyof T)[];
	/**
	 *  Filter object.
	 */
	filter?: RecursivePartial<T>;
	/**
	 * Tuple with a field and an order
	 */
	orderBy?: [
		Extract<keyof T, U>,
		"asc" | "desc"
	];
}
/**
 * ID used on TagoIO, string with 24 character
 */
export type GenericID = string;
/**
 * Token used on TagoIO, string with 36 characters
 */
export type GenericToken = string;
export type Base64 = string;
export type PermissionOption = "write" | "read" | "full" | "deny";
export type ExpireTimeOption = "never" | Date;
export type ExportOption = "csv" | "json" | "xml";
export type Conditionals = "<" | ">" | "=" | "!" | "><" | "*";
export type RunTypeOptions = "node" | "python";
export type TokenCreateResponse = {
	token: GenericToken;
	expire_date: ExpireTimeOption;
	permission: PermissionOption;
};
export interface TokenDataList {
	token: GenericToken;
	name: string;
	type: string;
	permission: PermissionOption;
	serie_number: string | null;
	last_authorization: Date | null;
	verification_code: string | null;
	expire_time: ExpireTimeOption;
	ref_id: string;
	created_at: Date;
	created_by: string | null;
}
export interface TokenData {
	/**
	 * A name for the token.
	 */
	name: string;
	/**
	 * The time for when the token should expire.
	 * It will be randomly generated if not included.
	 * Accepts “never” as value.
	 */
	expire_time?: ExpireTimeOption;
	/**
	 * Token permission should be 'write', 'read' or 'full'.
	 */
	permission: PermissionOption;
	/**
	 * [optional] The serial number of the device.
	 */
	serie_number?: string;
	/**
	 * [optional] Verification code to validate middleware requests.
	 */
	verification_code?: string;
	/**
	 * [optional] Middleware or type of the device that will be added.
	 */
	middleware?: string;
}
export interface ListTokenQuery extends Query<TokenDataList, "name" | "permission" | "serie_number" | "verification_code" | "created_at"> {
}
export type Regions = "usa-1" | "env";
export interface GenericModuleParams {
	token?: string;
	region?: Regions;
}
export interface ConnectorModuleParams extends GenericModuleParams {
	details?: boolean;
}
export interface AuthorizationModuleParams extends GenericModuleParams {
	details?: boolean;
}
/**
 * Object for generate request params
 * @internal
 */
export interface doRequestParams {
	path: string;
	method: Method;
	body?: any;
	params?: any;
	headers?: any;
	overwriteAxiosConfig?: AxiosRequestConfig;
	maxContentLength?: number;
	/**
	 * Cache for request
	 * default: false (disabled)
	 */
	cacheTTL?: number;
}
declare abstract class TagoIOModule<T extends GenericModuleParams> {
	protected params: T;
	constructor(params: T);
	private validateParams;
	protected doRequest<TR>(requestObj: doRequestParams): Promise<TR>;
	protected static doRequestAnonymous<TR>(requestObj: doRequestParams, region?: Regions): Promise<TR>;
}
export type ExportBucket = {
	id: string;
	origin: string;
	variables: string[];
}[];
export interface ExportBucketOption {
	start_date?: Date;
	end_date?: Date;
}
export interface BucketCreateInfo {
	/**
	 * A name for the bucket.
	 */
	name: string;
	/**
	 * Description for the bucket.
	 */
	description?: string | void;
	/**
	 * Set if the bucket will be visible or not. Default True.
	 */
	visible?: boolean;
	/**
	 * An array of tags.
	 */
	tags?: TagsObj[];
}
/**
 * Type of data storage for a device (bucket).
 */
export type DataStorageType = "immutable" | "mutable" | "legacy";
export type ChunkPeriod = "day" | "week" | "month" | "quarter";
export interface BucketInfoBasic extends BucketCreateInfo {
	id: GenericID;
	/**
	 * Data storage type for the bucket.
	 */
	profile: GenericID;
	last_retention: string | void;
	created_at: Date;
	updated_at: Date;
	chunk_period?: ChunkPeriod;
	chunk_retention?: number;
	data_retention?: string;
	data_retention_ignore?: [
	];
}
export type BucketInfoImmutable = Omit<BucketInfoBasic, "data_retention" | "data_retention_ignore"> & {
	type: "immutable";
	/**
	 * Chunk division to retain data in the device.
	 *
	 * Always returned for Immutable devices.
	 */
	chunk_period: ChunkPeriod;
	/**
	 * Amount of chunks to retain data according to the `chunk_period`.
	 *
	 * Always returned for Immutable devices.
	 */
	chunk_retention: number;
};
export type BucketInfoMutable = Omit<BucketInfoBasic, "chunk_period" | "chunk_retention" | "data_retention" | "data_retention_ignore"> & {
	type: "mutable";
};
/**
 * @deprecated
 */
export type BucketInfoLegacy = Omit<BucketInfoBasic, "chunk_period" | "chunk_retention"> & {
	type: "legacy";
	data_retention: string;
	data_retention_ignore: [
	];
};
export type BucketInfo = BucketInfoImmutable | BucketInfoMutable | BucketInfoLegacy;
export interface BucketDeviceInfo {
	id: GenericID;
	name: string;
}
export interface VariablesInfo {
	variable: string;
	origin: GenericID;
	origin_name?: string;
	amount?: number;
	deleted?: {
		origin: string;
		created_at: string;
	}[];
}
export interface ListVariablesOptions {
	/**
	 * return amount of each variable
	 */
	showAmount?: boolean;
	/**
	 * return array of async deleted
	 */
	showDeleted?: boolean;
	/**
	 * Change origins to array of object with id and name
	 */
	resolveOriginName?: boolean;
}
export type BucketQuery = Query<BucketInfo, "name" | "visible" | "data_retention" | "created_at" | "updated_at">;
export interface DeviceQuery extends Query<DeviceInfo, "name" | "visible" | "active" | "last_input" | "created_at" | "updated_at"> {
	resolveBucketName?: boolean;
}
export interface DeviceCreateInfoBasic {
	/**
	 * Device name.
	 */
	name: string;
	/**
	 * Connector ID.
	 */
	connector: GenericID;
	/**
	 * Network ID.
	 */
	network: GenericID;
	/**
	 * Device's data storage (bucket) type.
	 *
	 * @default "legacy"
	 */
	type?: DataStorageType;
	/**
	 * Description of the device.
	 */
	description?: string | void;
	/**
	 * Set if the device will be active.
	 */
	active?: boolean;
	/**
	 * Set if the device will be visible.
	 */
	visible?: boolean;
	/**
	 * An array of configuration params
	 */
	configuration_params?: ConfigurationParams[];
	/**
	 * An array of tags
	 */
	tags?: TagsObj[];
	/**
	 * Device serial number.
	 */
	serie_number?: string;
	/**
	 * If device will use connector parser
	 */
	connector_parse?: boolean;
	/**
	 * Javascript code for use as payload parser
	 */
	parse_function?: string;
}
export interface DeviceCreateInfoMutable extends Omit<DeviceCreateInfoBasic, "type"> {
	type: "mutable";
}
export interface DeviceCreateInfoImmutable extends Omit<DeviceCreateInfoBasic, "type"> {
	type: "immutable";
	/**
	 * Chunk division to retain data in the device.
	 *
	 * Required for Immutable devices.
	 */
	chunk_period: "day" | "week" | "month" | "quarter";
	/**
	 * Amount of chunks to retain data according to the `chunk_period`.
	 * Integer between in the range of 0 to 36 (inclusive).
	 *
	 * Required for Immutable devices.
	 */
	chunk_retention: number;
}
/**
 * @deprecated
 */
export interface DeviceCreateInfoLegacy extends Omit<DeviceCreateInfoBasic, "type"> {
	type: "legacy";
}
export type DeviceCreateInfo = DeviceCreateInfoLegacy | DeviceCreateInfoMutable | DeviceCreateInfoImmutable;
export type DeviceEditInfo = Partial<Omit<DeviceCreateInfo, "chunk_period" | "type"> & {
	chunk_retention: number;
}>;
export interface DeviceInfo extends Required<Omit<DeviceCreateInfoBasic, "configuration_params">> {
	/**
	 * Device ID.
	 */
	id: GenericID;
	/**
	 * Device's data storage (bucket) type.
	 */
	type: DataStorageType;
	/**
	 * ID of the profile that owns the device.
	 */
	profile: GenericID;
	/**
	 * Bucket storing the device's data.
	 */
	bucket: {
		id: GenericID;
		name: string;
	};
	/**
	 * Date for the device's last output.
	 */
	last_output: Date | null;
	/**
	 * Date for the device's last input.
	 */
	last_input: Date | null;
	/**
	 * Date for the device's last update.
	 */
	updated_at: Date;
	/**
	 * Date for the device's creation.
	 */
	created_at: Date;
	/**
	 * Date for the device's last inspection.
	 */
	inspected_at: Date | null;
	/**
	 * Date for the device's last data retention.
	 */
	last_retention: Date | null;
}
export interface ConfigurationParams {
	sent: boolean;
	key: string;
	value: string;
	id?: string;
}
export type DeviceCreateResponse = {
	device_id: GenericID;
	bucket_id: GenericID;
	token: GenericToken;
};
export type DeviceListItem = Omit<DeviceInfo, "bucket"> & {
	bucket: GenericID;
};
export interface DeviceTokenDataList {
	token: GenericToken;
	device_id: GenericID;
	network_id: GenericID;
	name: string;
	permission: PermissionOption;
	serie_number: string | void;
	last_authorization: string | void;
	expire_time: ExpireTimeOption;
	created_at: string;
}
export interface ListDeviceTokenQuery extends Query<DeviceTokenDataList, "name" | "permission" | "serie_number" | "last_authorization" | "created_at"> {
}
export interface DeviceChunkData {
	amount: number | null;
	id: string;
	from: string;
	to: string;
}
export interface DeviceChunkParams {
	deviceID: GenericID;
	chunkID: string;
	/**
	 *
	 * Enable headers to the CSV-generated files.
	 * Headers will describe the variable's
	 * data in each column.
	 */
	headers: boolean;
	/**
	 *
	 * The file address is the string template used to compose,
	 * the chunk's file path on TagoIO Files.
	 *
	 * You can use the keys $DEVICE$, $CHUNK$, $FROM$ and $TO$ that
	 * will be automically replaced when building the path.
	 *
	 * $DEVICE$ - Device ID
	 *
	 * $CHUNK$ - Chunk ID
	 *
	 * $FROM$ - The chunk from date (ex: 2022-05-1)
	 *
	 * $TO$ - The chunk to date (ex: 2022-05-2)
	 *
	 * @example
	 *
	 * /devices/$DEVICE$/$FROM$_$TO$
	 *
	 */
	file_address: string;
}
export interface DeviceChunkCopyResponse {
	chunk_id: string;
	file_address: string;
	status: "scheduled";
}
export interface DeviceItem {
	id: GenericID;
	profile: string;
	bucket: {
		id: GenericID;
		name: string;
	};
	name: string;
	description: string | void;
	visible: boolean;
	active: boolean;
	last_output: Date | null;
	last_input: Date | null;
	connector: string;
	network: string;
	connector_parse: boolean;
	parse_function: string;
	tags: TagsObj[];
	updated_at: Date;
	created_at: Date;
	inspected_at: Date | null;
	bucket_name?: string;
}
/**
 * @param token token
 */
export interface DeviceConstructorParams {
	token: GenericToken;
	region?: Regions;
}
export type valuesTypes = string | number | boolean | void;
export interface DataQueryBase {
	/**
	 * Filter by variables
	 * It can ben a array of string or only one string
	 */
	variables?: string[] | string;
	/**
	 * Filter by origins
	 * It can ben a array of string or only one string
	 *
	 * @deprecated Filtering by origins will be removed along with the Legacy buckets.
	 */
	origins?: string[] | string;
	/**
	 * Filter by series
	 * It can ben a array of string or only one string
	 *
	 * @deprecated Deprecating this in favor of `groups`.
	 */
	series?: string[] | string;
	/**
	 * Filter by groups.
	 *
	 * It can ben a array of strings or only one string, each string being a `group`.
	 */
	groups?: string[] | string;
	/**
	 * Filter by ids
	 * It can ben a array of string or only one string
	 */
	ids?: string[] | string;
	/**
	 * Filter by values
	 * It can ben a array or only one element
	 */
	values?: valuesTypes[] | valuesTypes;
	/**
	 * Set the start date of query
	 */
	start_date?: Date | string;
	/**
	 * Set the end date of query
	 * @default
	 * Date.now()
	 */
	end_date?: Date | string;
}
export type DataQueryDefault = DataQueryBase & {
	query?: "default";
	/**
	 * Qty of records to retrieve
	 */
	qty?: number;
	/**
	 * Add internal details in each record
	 */
	details?: boolean;
	/**
	 * Change ordination of query
	 * @default "descending"
	 */
	ordination?: "descending" | "ascending";
	/**
	 * Skip records, used on pagination or pooling
	 */
	skip?: number;
};
export type DataQueryFirstLast = DataQueryBase & {
	query: "last_item" | "last_value" | "last_location" | "last_insert" | "first_item" | "first_value" | "first_location" | "first_insert";
};
export type DataQueryAggregation = Omit<DataQueryBase, "start_date"> & {
	query: "avg" | "sum";
	start_date: Date | string;
};
export type DataQuerySummary = DataQueryBase & {
	query: "min" | "max" | "count";
};
export type DataQuery = DataQueryDefault | DataQueryFirstLast | DataQuerySummary | DataQueryAggregation;
export type DataQueryStreaming = Omit<DataQueryDefault, "qty" | "skip" | "query" | "ordination">;
export interface OptionsStreaming {
	/**
	 * Qty of records by pooling
	 * @default 1000
	 */
	poolingRecordQty?: number;
	/**
	 * Time (milliseconds) between each request
	 * @default 1000 = (1 second)
	 */
	poolingTime?: number;
	/**
	 * Never Stop pooling data
	 * The streaming will not stop after get all data
	 * @default false
	 */
	neverStop?: boolean;
}
export declare class Device extends TagoIOModule<DeviceConstructorParams> {
	/**
	 * Get information about the current device
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.info();
	 * ```
	 */
	info(): Promise<DeviceItem>;
	/**
	 * Send data to device
	 * @param data An array or one object with data to be send to TagoIO using device token
	 * @return amount of data added
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.sendData({
	 *   variable: "temperature",
	 *   unit: "F",
	 *   value: 55,
	 *   time: "2015-11-03 13:44:33",
	 *   location: { lat: 42.2974279, lng: -85.628292 },
	 * });
	 * ```
	 */
	sendData(data: DataCreate | DataCreate[]): Promise<string>;
	/**
	 * Get data from TagoIO Device.
	 * @param queryParams Object with query params
	 * @returns An array of TagoIO registers
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.getData({
	 *   query: "last_item",
	 *   variable: "humidity",
	 * });
	 * ```
	 */
	getData(queryParams?: DataQuery): Promise<Data[]>;
	/**
	 * Edit data in a Mutable-type device.
	 *
	 * @param data Array or object with the data to be edited, each object with the data's ID.
	 *
	 * @example
	 * ```ts
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.editData({
	 *   id: "id_of_the_data_item",
	 *   value: 123,
	 *   time: "2022-04-01 12:34:56",
	 *   location: { lat: 42.2974279, lng: -85.628292 },
	 * });
	 * ```
	 *
	 * @returns Success message with the amount of data items updated.
	 */
	editData(data: DataEdit | DataEdit[]): Promise<string>;
	/**
	 * Delete data from device
	 * @param queryParams
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.deleteData({
	 *   query: "last_item",
	 *   variable: "humidity",
	 *   value: 10
	 * });
	 * ```
	 */
	deleteData(queryParams?: DataQuery): Promise<string>;
	/**
	 * Get parameters from device
	 * @param onlyUnRead set true to get only unread parameters
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.getParameters();
	 * ```
	 */
	getParameters(status: "all" | "onlyUnRead" | "onlyRead"): Promise<ConfigurationParams[]>;
	/**
	 * Mark parameter as read
	 * @param parameterID Parameter identification
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const result = await myDevice.setParameterAsRead("parameter_id");
	 * ```
	 *
	 */
	setParameterAsRead(parameterID: GenericID): Promise<string>;
	/**
	 * Get Data Streaming
	 *
	 * @experimental
	 * @param params Data Query
	 * @param options Stream options
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * for await (const items of myDevice.getDataStreaming()) {
	 *  console.log(items);
	 * }
	 * ```
	 */
	getDataStreaming(params?: DataQueryStreaming, options?: OptionsStreaming): AsyncGenerator<Data[], void, unknown>;
	/**
	 * Stream data to device
	 *
	 * @experimental
	 * @param data An array or one object with data to be send to TagoIO using device token
	 * @param options Stream options
	 * @example
	 * ```js
	 * const myDevice = new Device({ token: "my_device_token" });
	 *
	 * const data = [
	 *     {
	 *       variable: "temperature",
	 *       unit: "F",
	 *       value: 55,
	 *       time: "2015-11-03 13:44:33",
	 *       location: { lat: 42.2974279, lng: -85.628292 },
	 *     },
	 *     {
	 *       variable: "temperature",
	 *       unit: "F",
	 *       value: 53,
	 *       time: "2015-11-03 13:44:33",
	 *       location: { lat: 43.2974279, lng: -86.628292 },
	 *     },
	 *     // ...
	 *   ];
	 *
	 *   const result = await myDevice.sendDataStreaming(data, {
	 *     poolingRecordQty: 1000,
	 *     poolingTime: 1000,
	 *   });
	 * ```
	 */
	sendDataStreaming(data: DataCreate[], options: Omit<OptionsStreaming, "neverStop">): Promise<string>;
}
export type analysisFunction = (context: any, data: any) => any;
export interface AnalysisConstructorParams {
	token?: string;
	region?: Regions;
	/**
	 * Auto Start analysis after instance the class
	 * If turn it off, you can start analysis calling [AnalysisInstance].start();
	 * [Default: true]
	 */
	autostart?: boolean;
	/**
	 * Load TagoIO Analysis envs on process.env.
	 *
	 * Warning: It's not safe to use on external analysis
	 * It will load all env on process, then if the external analysis receive multiples requests
	 * simultaneous, it can mass up.
	 *
	 * [Default: false]
	 */
	loadEnvOnProcess?: boolean;
}
/**
 * This class is used to instance an analysis
 *
 * It's can run locally or on TagoIO.
 */
export declare class Analysis extends TagoIOModule<AnalysisConstructorParams> {
	private analysis;
	started: boolean;
	constructor(analysis: analysisFunction, params?: AnalysisConstructorParams);
	start(): void;
	private runOnTagoIO;
	private stringifyMsg;
	/**
	 * Run Analysis
	 * @internal
	 * @param environment
	 * @param data
	 * @param analysis_id
	 * @param token
	 */
	private runLocal;
	private localRuntime;
	static use(analysis: analysisFunction, params?: AnalysisConstructorParams): Analysis;
}
export interface AccessCreateInfo {
	name: string;
	permissions: [
	];
	targets: [
	];
	profile?: GenericID;
	tags?: TagsObj[];
	active?: number;
}
export interface AccessInfo extends AccessCreateInfo {
	id: GenericID;
	created_at: Date;
	updated_at: Date;
}
export type AccessQuery = Query<AccessInfo, "name" | "active" | "created_at" | "updated_at">;
declare class Access extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list with all Access rules from account
	 * @default
	 * ```json
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name", "tags"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 * }
	 * ```
	 * @param queryObj Search query params
	 */
	list(queryObj?: AccessQuery): Promise<AccessInfo[]>;
	/**
	 * Create a new access policy
	 * @param accessObj
	 */
	create(accessObj: AccessCreateInfo): Promise<{
		am_id: GenericID;
	}>;
	/**
	 * Edit access policy
	 * @param accessID Access policy identification
	 * @param accessObj Access policy info to change
	 */
	edit(accessID: GenericID, accessObj: Partial<AccessInfo>): Promise<string>;
	/**
	 * Delete account policy
	 * @param accessID Access policy identification
	 */
	delete(accessID: GenericID): Promise<string>;
	/**
	 * Get account policy info
	 * @param accessID Access policy identification
	 */
	info(accessID: GenericID): Promise<AccessInfo>;
}
export type ActionType = "condition" | "resource" | "interval" | "schedule" | "mqtt_topic";
export type ActionTypeParams = {
	script: GenericID[];
	type: "script";
} | {
	message: string;
	subject: string;
	type: "notification";
} | {
	message: string;
	subject: string;
	run_user: GenericID;
	type: "notification_run";
} | {
	message: string;
	subject: string;
	to: string;
	type: "email";
} | {
	message: string;
	to: string;
	type: "sms";
} | {
	bucket: string;
	payload: string;
	topic: string;
	type: "mqtt";
} | {
	headers: {};
	type: "post";
	url: string;
};
export type ActionTriggerType = {
	resource: "device" | "bucket" | "file" | "analysis" | "action" | "am" | "user" | "financial" | "profile";
	when: "create" | "update" | "delete";
	tag_key: string;
	tag_value: string;
} | {
	interval: string;
} | {
	timezone: string | Date;
	cron: string;
} | {
	device: string;
	variable: string;
	is: Conditionals;
	value: string;
	second_value?: string;
	value_type: "string" | "number" | "boolean" | "*";
	unlock?: boolean;
};
export interface ActionCreateInfo {
	/**
	 * The name for the action.
	 */
	name: string;
	/**
	 * Profile identification
	 */
	profile?: GenericID;
	/**
	 * True if the action is active or not. The default is true.
	 */
	active?: boolean;
	/**
	 * An array of tags.
	 */
	tags?: TagsObj[];
	/**
	 * Description of the action.
	 */
	description?: string | null;
	lock?: boolean;
	/**
	 * Type of action
	 */
	type?: ActionType;
	/**
	 * Array of trigger configuration according to type
	 */
	trigger?: ActionTriggerType[];
	/**
	 * Action configuration
	 */
	action?: ActionTypeParams;
	/**
	 * Action action.
	 */
	id?: GenericID;
}
export interface ActionInfo extends ActionCreateInfo {
	id: GenericID;
	last_triggered: ExpireTimeOption;
	updated_at: Date;
	created_at: Date;
}
export type ActionQuery = Query<ActionInfo, "name" | "active" | "last_triggered" | "created_at" | "updated_at">;
declare class Actions extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list with all actions from the account
	 * @default
	 * ```json
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 * }
	 * ```
	 * @param queryObj Search query params
	 */
	list(queryObj?: ActionQuery): Promise<ActionInfo[]>;
	/**
	 * Generates and retrieves a new action from the account
	 * @param actionObj Object data to create new TagoIO Action
	 */
	create(actionObj: ActionCreateInfo): Promise<{
		action: string;
	}>;
	/**
	 * Modify any property of the action.
	 * @param actionID Action ID
	 * @param actionObj Action Object with data to be replaced
	 */
	edit(actionID: GenericID, actionObj: Partial<ActionCreateInfo>): Promise<string>;
	/**
	 * Deletes an action from the account
	 * @param actionID Action ID
	 */
	delete(actionID: GenericID): Promise<string>;
	/**
	 * Gets information about the action
	 * @param actionID Action ID
	 */
	info(actionID: GenericID): Promise<ActionInfo>;
}
export interface ScriptFile {
	name: string;
	content: Base64;
	language: RunTypeOptions;
}
export interface AnalysisCreateInfo {
	name: string;
	description?: string | null;
	interval?: string;
	run_on?: "tago" | "external";
	file_name?: string;
	runtime?: RunTypeOptions;
	active?: true;
	profile?: GenericID;
	variables?: {
		key: string;
		value: string | number | boolean;
	};
	tags?: TagsObj[];
}
export interface AnalysisInfo extends AnalysisCreateInfo {
	id: GenericID;
	token: string;
	last_run: ExpireTimeOption;
	created_at: Date;
	updated_at: Date;
	locked_at: any;
	console?: string[];
}
export type AnalysisQuery = Query<AnalysisInfo, "name" | "active" | "run_on" | "last_run" | "created_at" | "updated_at">;
declare class Analyses extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list with all analyses from the account
	 * @default
	 * ```json
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 * }
	 * ```json
	 * @param queryObj Search query params
	 */
	list(queryObj?: AnalysisQuery): Promise<AnalysisInfo[]>;
	/**
	 * Create a new analyze
	 * @param analysisObj data object to create new TagoIO Analyze
	 */
	create(analysisObj: AnalysisCreateInfo): Promise<{
		id: GenericID;
		token: GenericToken;
	}>;
	/**
	 * Modify any property of the analyze.
	 * @param analysisID Analyze identification
	 * @param analysisObj Analyze Object with data to replace
	 */
	edit(analysisID: GenericID, analysisObj: Partial<AnalysisInfo>): Promise<string>;
	/**
	 * Deletes an analyze from the account
	 * @param analysisID Analyze identification
	 */
	delete(analysisID: GenericID): Promise<string>;
	/**
	 * Gets information about the analyze
	 * @param analysisID Analyze identification
	 */
	info(analysisID: GenericID): Promise<AnalysisInfo>;
	/**
	 * Force analyze to run
	 * @param analysisID Analyze identification
	 * @param scopeObj simulate scope for analysis
	 */
	run(analysisID: GenericID, scopeObj?: Object | any): Promise<{
		analysis_token: GenericToken;
	}>;
	/**
	 * Generate a new token for the analysis
	 * @param analysisID Analyze identification
	 */
	tokenGenerate(analysisID: GenericID): Promise<string>;
	/**
	 * Upload a file (base64) to Analysis. Automatically erase the old one
	 * @param analysisID Analyze identification
	 * @param fileObj Object with name, language and content of the file
	 */
	uploadScript(analysisID: GenericID, fileObj: ScriptFile): Promise<string>;
	/**
	 * Get a url to download the analysis.
	 * If `version` is specified in `options`, downloads a specific version.
	 *
	 * @param analysisID Analysis identification
	 * @param options Options for the Analysis script to download
	 */
	downloadScript(analysisID: GenericID, options?: {
		version?: number;
	}): Promise<{
		url: string;
		size_unit: string;
		size: number;
		expire_at: Date;
	}>;
}
export type BillingPlan = "free" | "starter" | "scale";
export type BillingService = "input" | "output" | "analysis" | "data_records" | "sms" | "email" | "run_users" | "push_notification" | "file_storage";
export type BillingAddOn = "mobile" | "custom_dns";
export type BillingServiceSubscription = {
	limit: number;
};
export type BillingSubscriptionServices = Record<BillingService, BillingServiceSubscription>;
export type BillingSubscriptionAddOns = Record<BillingAddOn, GenericID[]>;
export type BillingPaymentError = {
	/**
	 * Payment error message.
	 */
	message: string | null;
	/**
	 * More details on the payment error.
	 */
	details: string | null;
};
export type BillingPaymentPastDue = {
	/**
	 * Amount due that was not paid in a recurring payment.
	 */
	amount_due: number;
	/**
	 * Amount of attempts for the retried recurring payment.
	 */
	attempt_count: number;
	/**
	 * URL for the invoice related to the failed recurring payment.
	 */
	invoice_url: string;
};
export type BillingSubscription = {
	/**
	 * Account ID.
	 */
	account: GenericID;
	/**
	 * Account plan.
	 */
	plan: BillingPlan;
	/**
	 * Limits for each service in the account's subscription.
	 */
	services: BillingSubscriptionServices;
	/**
	 * Add-ons in the account's subscription.
	 */
	addons: BillingSubscriptionAddOns;
	/**
	 * Current cycle for the account's subscription.
	 */
	current_cycle: {
		/**
		 * Date when the current cycle started.
		 */
		start: string;
		/**
		 * Date when the current cycle ends.
		 */
		end: string;
	};
	/**
	 * Whether changes are still being processed and awaiting response from Stripe.
	 */
	processing: boolean;
	/**
	 * Payment errors in the account's subscription.
	 */
	payment_error?: BillingPaymentError;
	/**
	 * Past due information for recurring payment errors.
	 */
	past_due?: BillingPaymentPastDue;
	/**
	 * Value of the upcoming invoice.
	 */
	upcoming_invoice_total: number;
	/**
	 * Timestamp when the trial for the subscription ends if the subscription has a trial active.
	 */
	trial_end: string | null;
};
export type BillingEditSubscription = {
	/**
	 * New account plan.
	 *
	 * Only one of `plan`, `services` and `addons` is accepted.
	 */
	plan?: BillingPlan;
	/**
	 * New limits for each service in the account's subscription.
	 *
	 * Only one of `plan`, `services` and `addons` is accepted.
	 */
	services?: Partial<BillingSubscriptionServices>;
	/**
	 * New add-ons in the account's subscription.
	 *
	 * Only one of `plan`, `services` and `addons` is accepted.
	 */
	addons?: Partial<BillingSubscriptionAddOns>;
	/**
	 * Coupon code.
	 */
	coupon?: string;
};
export type BillingServiceSubscriptionSchedule = Record<BillingService, BillingServiceSubscription & {
	/**
	 * Amount of proportional change the service's allocation will undergo.
	 */
	proportional_change?: number | undefined;
}>;
export type BillingSubscriptionSchedule = {
	/**
	 * Account plan after the downgrade is applied.
	 */
	plan?: BillingPlan;
	/**
	 * Limits for each service in the account's subscription after the downgrade is applied.
	 */
	services?: BillingServiceSubscriptionSchedule;
	/**
	 * Add-ons in the account's subscription after the downgrade is applied.
	 */
	addons?: Partial<BillingSubscriptionAddOns>;
};
export type BillingSchedule = {
	/**
	 * Account ID.
	 */
	account: GenericID;
	/**
	 * When the schedule will be applied to the subscription.
	 */
	release_at: string | null;
	/**
	 * Scheduled subscription changes.
	 */
	subscription?: BillingSubscriptionSchedule;
};
export type BillingServicePrice = {
	/**
	 * Amount available in the service tier.
	 */
	amount: number;
	/**
	 * Price for the service tier.
	 */
	price: number;
};
export type BillingAllServicePrices = Record<BillingService, BillingServicePrice[]>;
export type BillingPlanPrices = Array<{
	/**
	 * Plan name.
	 */
	name: BillingPlan;
	/**
	 * Plan price.
	 */
	price: number;
}>;
export type BillingAddOnPrices = Array<{
	/**
	 * Add-on name.
	 */
	name: BillingAddOn;
	/**
	 * Add-on price.
	 */
	price: number;
}>;
export type BillingPrices = {
	/**
	 * Prices for each plan.
	 */
	plans: BillingPlanPrices;
	/**
	 * Prices for each add-on.
	 */
	addons: BillingAddOnPrices;
} & BillingAllServicePrices;
export type BillingPaymentMethodCard = {
	/**
	 * Name on the credit card.
	 */
	name: string;
	/**
	 * Credit card brand.
	 */
	brand: string;
	/**
	 * Credit card's last four digits.
	 */
	last4: string;
	/**
	 * Credit card funding type.
	 */
	funding: string;
	/**
	 * Credit card's expiration month.
	 */
	exp_month: number;
	/**
	 * Credit card's expiration year.
	 */
	exp_year: number;
};
export type BillingPaymentMethodBalance = {
	/**
	 * Amount of credit in balance.
	 */
	amount: number;
	/**
	 * Currency of the credit balance.
	 */
	currency: string;
};
export type BillingCoupon = {
	/**
	 * Coupon promotional code (if customer-facing) or coupon name.
	 */
	code: string;
	/**
	 * Amount off the original value.
	 *
	 * Only one of `amount_off` and `percentage_off` will not be `null`.
	 */
	amount_off: number | null;
	/**
	 * Percentage off the original value.
	 *
	 * Only one of `amount_off` and `percentage_off` will not be `null`.
	 */
	percentage_off: number | null;
	/**
	 * Services, plans, and add-ons the coupon is applicable to.
	 * Applies to everything when `null`.
	 */
	applies_to: Array<Exclude<BillingPlan, "free"> | BillingService | BillingAddOn> | null;
	/**
	 * Restrictions for coupon usage.
	 */
	restrictions?: {
		/**
		 * Whether the coupon can only be used on the first purchase.
		 */
		only_first_time: boolean;
		/**
		 * Minimum value of the purchase so this coupon is applicable.
		 */
		minimum_order_value: number | null;
	};
	/**
	 * Duration cycles for the coupon.
	 *
	 * Number is months, `once` means the coupon is only valid for one purchase or one billing.
	 */
	duration_cycles: number | "forever" | "once";
};
export type BillingPaymentMethod = {
	/**
	 * Credit card on record.
	 */
	card: BillingPaymentMethodCard | null;
	/**
	 * Account balance in Stripe.
	 */
	balance?: BillingPaymentMethodBalance;
	/**
	 * Coupon currently applied to the subscription.
	 */
	coupon?: BillingCoupon;
};
export type BillingSubscriptionSummary = {
	/**
	 * Whether the subscription has an operation still being processed.
	 */
	processing: boolean;
	/**
	 * Payment errors in the account's subscription.
	 */
	payment_error: BillingPaymentError | null;
	/**
	 * Whether the subscription has a failing recurring payment.
	 */
	past_due: boolean;
	/**
	 * Whether the subscription does not have enough account balance for the next
	 * recurring payment without a credit card on record.
	 */
	not_enough_balance: boolean;
	/**
	 * Whether the subscription has scheduled downgrades.
	 */
	schedule: boolean;
};
export type BillingPaymentHistoryEntry = {
	/**
	 * Stripe ID for the history entry. Used for pagination.
	 */
	stripe_id: string;
	/**
	 * Number of the invoice in Stripe for identification.
	 *
	 * May be `null` if Stripe does not provide it at the moment of the request.
	 */
	invoice_number?: string | null;
	/**
	 * Total cost of the invoice.
	 */
	total: number;
	/**
	 * Currency used for the invoice.
	 */
	currency: string;
	/**
	 * URL to download the invoice and receipt on Stripe.
	 *
	 * May be `null` if Stripe does not provide it at the moment of the request.
	 */
	receipt_url?: string | null;
	/**
	 * Whether the invoice was paid.
	 */
	paid: boolean;
	/**
	 * Payment status of the invoice.
	 */
	status: string;
	/**
	 * Information for the credit card used to pay the invoice.
	 */
	card: {
		/**
		 * Credit card brand.
		 */
		brand: string | null;
		/**
		 * Credit card's last four digits.
		 */
		last4: string | null;
	} | null;
	/**
	 * Timestamp for when the invoice was created.
	 */
	created_at: string;
};
export type BillingInformation = {
	/**
	 * Account ID.
	 */
	account: GenericID;
	/**
	 * Company registered in account's billing information.
	 */
	company: string;
	/**
	 * Country registered in account's billing information.
	 */
	country: string | null;
	/**
	 * State registered in account's billing information.
	 */
	state: string | null;
	/**
	 * City registered in account's billing information.
	 */
	city: string | null;
	/**
	 * Street address registered in account's billing information.
	 */
	street: string | null;
	/**
	 * Zip code registered in account's billing information.
	 */
	zip_code: string | null;
	/**
	 * Extra information to be attached to the invoice for tax and other purposes.
	 */
	comments: string | null;
	/**
	 * Payment method registered in account's billing information.
	 */
	payment_method: BillingPaymentMethod | null;
	/**
	 * Timestamp when the billing information was last updated.
	 */
	updated_at: string;
};
export type BillingEditInformation = Partial<Omit<BillingInformation, "account" | "updated_at" | "payment_method">>;
export type BillingResourceAllocationServices = Record<BillingService, number>;
export type BillingProfileResourceAllocation = {
	/**
	 * Profile ID.
	 */
	profile: GenericID;
	/**
	 * Timestamp when the resource allocation for the profile was last updated.
	 */
	updated_at: string;
} & BillingResourceAllocationServices;
export type BillingResourceAllocation = BillingProfileResourceAllocation[];
export type BillingEditResourceAllocation = Array<Partial<Omit<BillingProfileResourceAllocation, "updated_at">>>;
declare class Billing extends TagoIOModule<GenericModuleParams> {
	/**
	 * Get the account subscription information.
	 */
	getSubscription(): Promise<BillingSubscription>;
	/**
	 * Edit an account's subscription to change plan, services or add-ons.
	 *
	 * Only one of either `plan`, `services`, or `addons` can be in `subscription`.
	 *
	 * @param subscription Object with updates to subscription.
	 *
	 * @throws If the subscription has a pending operation.
	 * @throws If updating more than one of plan, services and add-ons at the same time.
	 * @throws If purchasing add-ons or changing service limits on the Free plan.
	 * @throws If using an invalid coupon.
	 */
	editSubscription(subscription: BillingEditSubscription): Promise<void>;
	/**
	 * Get information for the account subscription schedule for downgrades.
	 *
	 * In the response, `subscription` reflects how the entire subscription will look
	 * at the end of the billing cycle when the downgrade is applied. If there is a scheduled downgrade
	 * for either plan, services or add-ons, everything is returned and not only the changes.
	 */
	getSubscriptionSchedule(): Promise<BillingSchedule>;
	/**
	 * Get pricing for plans, services and add-ons.
	 */
	getPrices(): Promise<BillingPrices>;
	/**
	 * Get pricing for plans, services and add-ons with proration when applicable.
	 */
	getProratedPrices(): Promise<BillingPrices>;
	/**
	 * Get information about the account's payment method credit card, credit balance,
	 * and the applied coupon.
	 */
	getPaymentMethod(): Promise<BillingPaymentMethod>;
	/**
	 * Edit an account's payment method.
	 *
	 * @param stripeCardToken Token for the new payment method added via Stripe API.
	 *
	 * @throws If token is invalid or Stripe can't create the payment method with it.
	 *
	 * @returns Success or error message.
	 */
	editPaymentMethod(stripeCardToken: string): Promise<string>;
	/**
	 * Remove an account's payment method from the Stripe subscription.
	 *
	 * Only removes the card if the account is on the Free plan or if it has enough credit balance.
	 *
	 * @throws If subscription is active with an upcoming invoice.
	 * @throws If account doesn't have a payment method.
	 *
	 * @returns Success or error message.
	 */
	removePaymentMethod(): Promise<string>;
	/**
	 * Get an account's billing information.
	 */
	getBillingInformation(): Promise<BillingInformation>;
	/**
	 * Edit an account's billing information.
	 *
	 * @param billingInformation Data to be updated in the account's billing information.
	 */
	editBillingInformation(billingInformation: BillingEditInformation): Promise<string>;
	/**
	 * Get the resource allocation for all profiles in an account.
	 */
	getAllocation(): Promise<BillingResourceAllocation>;
	/**
	 * Edit the resource allocation for the profiles in an account.
	 *
	 * The resource allocation array doesn't need to have an object for each of the account's profiles,
	 * as long as the sum of the allocated amounts for the services doesn't exceed the account's service limit.
	 *
	 * The resource allocation object for a profile doesn't need to have all the services.
	 *
	 * @param allocation Array with the resource allocation
	 *
	 * @throws If passed an object that is not an allocation array.
	 * @throws If the account only has one profile.
	 * @throws If one of the profile IDs in the allocation array doesn't exist in the account.
	 * @throws If the allocated amount for one of the services exceeds the available amount.
	 *
	 * @returns Success message.
	 */
	editAllocation(allocation: BillingEditResourceAllocation): Promise<string>;
	/**
	 * Get the payment history for an account.
	 *
	 * The route uses pagination and the `lastId` parameter should be the `stripe_id`
	 * parameter from the last history entry.
	 *
	 * @param queryObj Object to configure the amount of entries fetched and the ID of the history entry for pagination.
	 *
	 * @throws If `lastId` is passed and is invalid.
	 *
	 * @returns Array with payment history entries or an empty array when no entries are available.
	 */
	getPaymentHistory(queryObj?: {
		amount?: number;
		lastId?: string;
	}): Promise<BillingPaymentHistoryEntry[]>;
	/**
	 * Get a summary for important information in an account's subscription.
	 *
	 * The values returned by this route are cached.
	 *
	 * @returns Summary data for a subscription or `undefined` when the account does not have a subscription.
	 */
	getSubscriptionSummary(): Promise<BillingSubscriptionSummary | undefined>;
	/**
	 * Check if a coupon is valid by its promo code.
	 *
	 * @param code Customer-facing code for the coupon (promo code).
	 *
	 * @throws If the coupon code is not valid or not found.
	 * @throws If coupon is specific to a an account.
	 * @throws If coupon can only be applied to new subscriptions.
	 */
	checkDiscountCoupon(code?: string): Promise<BillingCoupon>;
	/**
	 * Cancel a scheduled downgrade.
	 *
	 * @throws If the subscription has no schedule.
	 *
	 * @returns Success message.
	 */
	cancelDowngrade(): Promise<string>;
	/**
	 * Retry payment for an operation where the payment was unsuccessful.
	 *
	 * Works for payment errors in recurring payments or in subscription upgrade operations.
	 *
	 * @throws If account has no subscription.
	 * @throws If there's no pending payment.
	 * @throws If payment method is declined or for other payment processing errors.
	 *
	 * @returns Success message.
	 */
	retryLastPayment(): Promise<string>;
	/**
	 * Cancel the last pending operation if the payment has failed.
	 *
	 * Works for subscription upgrade operations and not for recurring payment errors.
	 *
	 * @throws If there's no pending payment.
	 *
	 * @returns Success message.
	 */
	cancelLastOperation(): Promise<string>;
}
declare class Buckets extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list with all buckets from account
	 * @default
	 * ```json
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 * }
	 * ```
	 * @param queryObj Search query params
	 */
	list(queryObj?: BucketQuery): Promise<BucketInfo[]>;
	/**
	 * Generates and retrieves a new bucket for the account
	 * @param bucketObj Object with data to create new bucket
	 */
	create(bucketObj: BucketCreateInfo): Promise<{
		bucket: string;
	}>;
	/**
	 * Modifies any property of the bucket.
	 * @param bucketID Bucket ID
	 * @param bucketObj Bucket Object data to be replaced
	 */
	edit(bucketID: GenericID, bucketObj: Partial<BucketCreateInfo>): Promise<string>;
	/**
	 * Deletes a bucket from the account
	 * @param bucketID Bucket ID
	 */
	delete(bucketID: GenericID): Promise<string>;
	/**
	 * Gets information about the bucket
	 * @param bucketID Bucket ID
	 */
	info(bucketID: GenericID): Promise<BucketInfo>;
	/**
	 * Get Amount of data on the Bucket
	 * @param bucketID Bucket ID
	 */
	amount(bucketID: GenericID): Promise<number>;
	/**
	 * List variables inside the bucket
	 * @default
	 * ```json
	 * optionsObj: {
	 *   showAmount: false
	 *   showDeleted: false
	 *   resolveOriginName: false
	 * }
	 * ```
	 * @param bucketID Bucket ID
	 * @param optionsObj Request options
	 */
	listVariables(bucketID: GenericID, optionsObj?: ListVariablesOptions): Promise<VariablesInfo[]>;
	/**
	 * Delete a bucket variable
	 * @param bucketID Bucket ID
	 * @param deleteParams Variable Details
	 */
	deleteVariable(bucketID: GenericID, deleteParams: {
		variable: string;
		origin: string;
	}): Promise<string>;
	/**
	 * Get all device associated with bucket
	 * @param bucketID Bucket ID
	 */
	getDevicesAssociated(bucketID: GenericID): Promise<BucketDeviceInfo[]>;
	/**
	 * Export Data from Bucket
	 * @param buckets Array of JSON with get details
	 * @param output Type of output
	 * @param optionsObj Options of request
	 */
	exportData(buckets: ExportBucket, output: ExportOption, optionsObj?: ExportBucketOption): Promise<string>;
}
export interface InviteResponse {
	expire_time: ExpireTimeOption;
	id: GenericID;
}
export interface InviteInfo {
	permission?: PermissionOption;
	status?: string;
	copy_me?: boolean;
	expire_time?: ExpireTimeOption;
	allow_share?: boolean;
	allow_tags?: boolean;
	id?: GenericID;
	name?: string;
	email: string;
}
export interface Arrangement {
	widget_id: string;
	x: number;
	y: number;
	width: number;
	height: number;
	tab?: string | null;
}
export interface DashboardCreateInfo {
	label: string;
	arrangement?: Arrangement[];
	tags?: TagsObj[];
	visible?: boolean;
}
export interface DashboardInfo extends DashboardCreateInfo {
	id: GenericID;
	created_at: Date;
	updated_at: Date;
	last_access: Date | null;
	group_by: [
	];
	tabs: [
	];
	icon: {
		url: string;
		color?: string;
	};
	background: any;
	type: string;
	blueprint_device_behavior: "more_than_one" | "always";
	blueprint_selector_behavior: void | "open" | "closed" | "always_open" | "always_closed";
	blueprint_devices: [
		{
			conditions: [
				{
					key: string;
					value: string;
				}
			];
			name: string;
			id: string;
			label?: string;
			filter_conditions?: [
				{
					blueprint_device: string;
					tag_key: string;
					type: string;
				}
			];
		}
	];
	theme: any;
	setup: any;
	shared: {
		id: string;
		email: string;
		name: string;
		free_account: boolean;
		allow_tags: boolean;
		expire_time: string;
		allow_share: boolean;
	};
}
export interface WidgetData {
	origin: GenericID;
	qty?: number;
	timezone?: string;
	variables?: string;
	bucket?: GenericID;
	query?: "min" | "max" | "count" | "avg" | "sum";
	start_date?: Date | string;
	end_date?: Date | string;
	overwrite?: boolean;
}
export interface WidgetResource {
	filter: TagsObj[];
}
export type ResourceTag = `tags.${string}`;
export type ResourceParam = `param.${string}`;
export type DeviceResourceView = ResourceTag | ResourceParam | "name" | "id" | "bucket_name" | "network_name" | "connector_name" | "connector" | "network" | "bucket" | "last_input" | "created_at" | "active";
export interface WidgetDeviceResource extends WidgetResource {
	type: "device";
	view: DeviceResourceView;
	editable: "name" | ResourceTag | ResourceParam;
}
/**
 * Allowed keys: tags.\* or param.\*
 *
 * The value must always be a string or boolean.
 */
export type EditDeviceResource = {
	device: GenericID;
	name?: string;
	active?: boolean;
} & {
	[key: string]: string | boolean;
};
export interface EditResourceOptions {
	/**
	 * Identifier to send to the Analysis scope in `widget_exec`.
	 */
	identifier?: string;
}
export interface WidgetInfo {
	analysis_run?: GenericID;
	dashboard?: GenericID;
	display: any;
	data?: WidgetData[];
	resource?: WidgetDeviceResource[];
	id?: GenericID;
	label: string;
	realtime?: boolean | null;
	type: string;
}
export interface DevicesRelated extends BucketDeviceInfo {
	bucket: GenericID;
}
export interface AnalysisRelated {
	id: GenericID;
	name: string;
}
export interface PostDataModel extends Omit<Data, "id" | "created_at"> {
	origin: GenericID;
	variable: string;
}
export interface GetDataModel {
	overwrite?: widgetOverwrite;
	blueprint_devices?: {
		origin: GenericID;
		id: GenericID;
		bucket?: GenericID;
	}[];
	page?: number;
	amount?: number;
}
export type EditDataModel = PostDataModel & {
	id: GenericID;
};
export type DashboardQuery = Query<DashboardInfo, "name" | "label" | "active" | "created_at" | "updated_at">;
export type PublicKeyResponse = {
	token: GenericToken;
	expire_time: ExpireTimeOption;
};
export type widgetOverwriteOptions = "start_date" | "end_date" | "timezone";
export type widgetOverwrite = {
	[key in widgetOverwriteOptions]: any;
};
declare class Widgets extends TagoIOModule<GenericModuleParams> {
	/**
	 * Create a Dashboard Widget
	 * @param dashboardID Dashboard identification
	 * @param widgetObj
	 */
	create(dashboardID: GenericID, widgetObj: WidgetInfo): Promise<{
		widget: GenericID;
	}>;
	/**
	 * Edit the Dashboard Widget
	 * @param dashboardID Dashboard identification
	 * @param widgetID Widget identification
	 * @param data
	 */
	edit(dashboardID: GenericID, widgetID: GenericID, data: Partial<WidgetInfo>): Promise<string>;
	/**
	 * Delete the Dashboard Widget
	 * @param dashboardID Dashboard identification
	 * @param widgetID Widget identification
	 */
	delete(dashboardID: GenericID, widgetID: GenericID): Promise<string>;
	/**
	 * Get Info of the Dashboard Widget
	 * @param dashboardID Dashboard identification
	 * @param widgetID Widget identification
	 */
	info(dashboardID: GenericID, widgetID: GenericID): Promise<WidgetInfo>;
	/**
	 * Get all data or resource list for the current widget
	 * @param dashboardID Dashboard identification
	 * @param widgetID Widget identification
	 * @param overwrite It can overwrite 'start_date', 'end_date', 'timezone' fields
	 */
	getData(dashboardID: GenericID, widgetID: GenericID, params?: GetDataModel): Promise<object>;
	/**
	 * Send value of variable for the current widget
	 * @param dashboardID Dashboard identification
	 * @param widgetID Widget identification
	 * @param data
	 * @param bypassBucket
	 */
	sendData(dashboardID: GenericID, widgetID: GenericID, data: PostDataModel | PostDataModel[], bypassBucket?: boolean): Promise<object>;
	/**
	 * Update value of variable for the current widget
	 * @param dashboardID Dashboard identification
	 * @param widgetID Widget identification
	 * @param data
	 * @param bypassBucket
	 */
	editData(dashboardID: GenericID, widgetID: GenericID, data: EditDataModel | EditDataModel[], bypassBucket?: boolean): Promise<object>;
	/**
	 * Update value of a resource for the current widget
	 * @param dashboardID Dashboard identification
	 * @param widgetID Widget identification
	 * @param resourceData Updated data for the resource
	 * @param options Additional options
	 */
	editResource(dashboardID: GenericID, widgetID: GenericID, resourceData: EditDeviceResource | EditDeviceResource[], options?: EditResourceOptions): Promise<object>;
	/**
	 * Run analysis without inserting data to bucket
	 * @param dashboardID Dashboard identification
	 * @param widgetID Widget identification
	 * @param data
	 */
	runAnalysis(dashboardID: GenericID, widgetID: GenericID, data: [
		object | Data
	]): Promise<object>;
	/**
	 * Delete data by it's id, bucket and variable must be associeted with the widget
	 * @param dashboardID Dashboard identification
	 * @param widgetID Widget identification
	 * @param ids
	 */
	deleteData(dashboardID: GenericID, widgetID: GenericID, ids: GenericID): Promise<string>;
	/**
	 * Generate a new token for the embed widgets
	 * It can regenerate the token if call it multi-times
	 * @param dashboardID Dashboard identification
	 * @param widgetID Widget identification
	 */
	tokenGenerate(dashboardID: GenericID, widgetID: GenericID): Promise<{
		widget_token: GenericToken;
	}>;
}
declare class Dashboards extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list with all dashboards from the account
	 * @default
	 * ```json
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "label,asc",
	 * }
	 * ```
	 * @param queryObj Search query params
	 */
	list(queryObj?: DashboardQuery): Promise<DashboardInfo[]>;
	/**
	 * Generates and retrieves a new dashboard from the account
	 * @param dashboardObj Object data to create new Dashboard
	 */
	create(dashboardObj: DashboardCreateInfo): Promise<{
		dashboard: GenericID;
	}>;
	/**
	 * Modify any property of the action
	 * @param dashboardID Dashboard identification
	 * @param dashboardObj Dashboard Object with data to be replaced
	 */
	edit(dashboardID: GenericID, dashboardObj: Partial<DashboardInfo>): Promise<string>;
	/**
	 * Deletes an dashboard from the account
	 * @param dashboardID Dashboard identification
	 */
	delete(dashboardID: GenericID): Promise<string>;
	/**
	 * Gets information about the dashboard
	 * @param dashboardID Dashboard identification
	 */
	info(dashboardID: GenericID): Promise<DashboardInfo>;
	/**
	 * Duplicate the dashboard to your own account
	 * @param dashboardID Dashboard identification
	 * @param dashboardObj Object with data of the duplicate dashboard
	 */
	duplicate(dashboardID: GenericID, dashboardObj?: {
		setup?: object;
		new_label?: string;
	}): Promise<{
		dashboard_id: string;
		message: string;
	}>;
	/**
	 * Get share list of the dashboard
	 * @param dashboardID Dashboard identification
	 */
	shareList(dashboardID: GenericID): Promise<InviteInfo[]>;
	/**
	 * Share the dashboard with another person
	 * @param dashboardID Dashboard identification
	 * @param inviteObj Object with target and message
	 */
	shareSendInvite(dashboardID: GenericID, inviteObj: InviteInfo): Promise<InviteResponse>;
	/**
	 * Change permissions of the bucket
	 * @param shareID Share identification
	 * @param targetObj Object with target email and new permission
	 */
	shareEdit(shareID: GenericID, targetObj: Partial<InviteInfo>): Promise<string>;
	/**
	 * Remove share of the bucket
	 * @param shareID Share identification
	 */
	shareDelete(shareID: GenericID): Promise<string>;
	/**
	 * Generate a new public token for the dashboard
	 * @param dashboardID Dashboard identification
	 * @param expireTime Time when token will expire
	 */
	getPublicKey(dashboardID: GenericID, expireTime?: ExpireTimeOption): Promise<PublicKeyResponse>;
	/**
	 * Get list of devices related with dashboard
	 * @param dashboardID Dashboard identification
	 */
	listDevicesRelated(dashboardID: GenericID): Promise<DevicesRelated[]>;
	/**
	 * Get list of analysis related with a dashboard
	 * @param dashboardID Dashboard identification
	 */
	listAnalysisRelated(dashboardID: GenericID): Promise<AnalysisRelated[]>;
	/**
	 * Runs an analysis located in a widget's header button
	 * @param analysisID The id of the analysis to run
	 * @param dashboardID The id of the dashboard that contains the widget
	 * @param widgetID The id of the widget that contains the header button
	 * @param scope Data to send to the analysis
	 */
	runWidgetHeaderButtonAnalysis(analysisID: GenericID, dashboardID: GenericID, widgetID: GenericID, scope?: object): Promise<string>;
	private share;
	widgets: Widgets;
}
declare class Devices extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list with all devices from the account
	 * @default
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 *   resolveBucketName: false
	 * }
	 * @param queryObj Search query params
	 */
	list(queryObj?: DeviceQuery): Promise<DeviceListItem[]>;
	/**
	 * Get a Streaming list of Devices from the account
	 *
	 * @experimental
	 * @param queryObj Search query params
	 * @param options Stream options
	 * @example
	 * ```js
	 * for await (const items of Resources.devices.listStreaming({ name: "*sensor*" })) {
	 *  console.log(items);
	 * }
	 * ```
	 */
	listStreaming(queryObj?: DeviceQuery["filter"], options?: OptionsStreaming): AsyncGenerator<DeviceListItem[], void, unknown>;
	/**
	 * Generates and retrieves a new action from the Device
	 * @param deviceObj Object data to create new device
	 */
	create(deviceObj: DeviceCreateInfo): Promise<DeviceCreateResponse>;
	/**
	 * Modify any property of the device
	 * @param deviceID Device ID
	 * @param deviceObj Device object with fields to replace
	 */
	edit(deviceID: GenericID, deviceObj: DeviceEditInfo): Promise<string>;
	/**
	 * Deletes an device from the account
	 * @param deviceID Device ID
	 */
	delete(deviceID: GenericID): Promise<string>;
	/**
	 * Get Info of the Device
	 * @param deviceID Device ID
	 */
	info(deviceID: GenericID): Promise<DeviceInfo>;
	/**
	 * Create or edit param for the Device
	 * @param deviceID Device ID
	 * @param configObj Configuration Data
	 * @param paramID Parameter ID
	 */
	paramSet(deviceID: GenericID, configObj: Partial<ConfigurationParams> | Partial<ConfigurationParams>[], paramID?: GenericID): Promise<string>;
	/**
	 * List Params for the Device
	 * @param deviceID Device ID
	 * @param sentStatus True return only sent=true, False return only sent=false
	 */
	paramList(deviceID: GenericID, sentStatus?: Boolean): Promise<ConfigurationParams[]>;
	/**
	 * Remove param for the Device
	 * @param deviceID Device ID
	 * @param paramID Parameter ID
	 */
	paramRemove(deviceID: GenericID, paramID: GenericID): Promise<string>;
	/**
	 * Retrieves a list of all tokens
	 * @default
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["name", "token", "permission"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "created_at,desc",
	 * }
	 * @param deviceID Device ID
	 * @param queryObj Search query params
	 */
	tokenList(deviceID: GenericID, queryObj?: ListDeviceTokenQuery): Promise<Partial<DeviceTokenDataList>[]>;
	/**
	 * Generates and retrieves a new token
	 * @param deviceID Device ID
	 * @param tokenParams Params for new token
	 */
	tokenCreate(deviceID: GenericID, tokenParams: TokenData): Promise<TokenCreateResponse>;
	/**
	 * Delete a token
	 * @param token Token
	 */
	tokenDelete(token: GenericToken): Promise<string>;
	/**
	 * Get data from all variables in the device.
	 *
	 * @param deviceId Device ID.
	 * @param queryParams Query parameters to filter the results.
	 *
	 * @returns Array with the data values stored in the device.
	 *
	 * @example
	 * ```ts
	 * const lastTenValues = await Resources.devices.getDeviceData("myDeviceId", { qty: 10 });
	 * ```
	 */
	getDeviceData(deviceId: GenericID, queryParams?: DataQuery): Promise<Data[]>;
	/**
	 * Get Data Streaming
	 *
	 * @experimental
	 * @param deviceId Device ID
	 * @param params Data Query
	 * @param options Stream options
	 * @example
	 * ```js
	 * for await (const items of Resources.devices.getDeviceDataStreaming("myDeviceId")) {
	 *  console.log(items);
	 * }
	 * ```
	 */
	getDeviceDataStreaming(deviceId: GenericID, params?: DataQueryStreaming, options?: OptionsStreaming): AsyncGenerator<Data[], void, unknown>;
	/**
	 * Empty all data in a device.
	 *
	 * @param deviceId Device ID.
	 *
	 * @returns Success message.
	 */
	emptyDeviceData(deviceId: GenericID): Promise<string>;
	/**
	 * Send data to device
	 *
	 * @param deviceId Device ID.
	 * @param data An array or one object with data to be send to TagoIO
	 * @return amount of data added
	 * @example
	 * ```js
	 * const result = await Resources.devices.sendDeviceData("myDeviceId", {
	 *   variable: "temperature",
	 *   unit: "F",
	 *   value: 55,
	 *   time: "2015-11-03 13:44:33",
	 *   location: { lat: 42.2974279, lng: -85.628292 },
	 * });
	 * ```
	 */
	sendDeviceData(deviceId: GenericID, data: DataCreate | DataCreate[]): Promise<string>;
	/**
	 * Stream data to device
	 *
	 * @experimental
	 * @param deviceId Device ID.
	 * @param data An array or one object with data to be send to TagoIO using device token
	 * @param options Stream options
	 * @example
	 * ```js
	 * const data = [
	 *     {
	 *       variable: "temperature",
	 *       unit: "F",
	 *       value: 55,
	 *       time: "2015-11-03 13:44:33",
	 *       location: { lat: 42.2974279, lng: -85.628292 },
	 *     },
	 *     {
	 *       variable: "temperature",
	 *       unit: "F",
	 *       value: 53,
	 *       time: "2015-11-03 13:44:33",
	 *       location: { lat: 43.2974279, lng: -86.628292 },
	 *     },
	 *     // ...
	 *   ];
	 *
	 *   const result = await Resources.devices.sendDeviceDataStreaming("myDeviceId", data, {
	 *     poolingRecordQty: 1000,
	 *     poolingTime: 1000,
	 *   });
	 * ```
	 */
	sendDeviceDataStreaming(deviceId: GenericID, data: DataCreate[], options?: Omit<OptionsStreaming, "neverStop">): Promise<string>;
	/**
	 * Edit data records in a device using the profile token and device ID.
	 *
	 * The `updatedData` can be a single data record or an array of records to be updated,
	 * each of the records must have the `id` of the record and the fields to be updated.
	 *
	 * @param deviceId Device ID.
	 * @param updatedData A single or an array of updated data records.
	 *
	 * @returns Success message indicating amount of records updated (can be 0).
	 *
	 * @example
	 * ```ts
	 * await Resources.devices.editDeviceData("myDeviceId", { id: "idOfTheRecord", value: "new value", unit: "new unit" });
	 * ```
	 */
	editDeviceData(deviceId: GenericID, updatedData: DataEdit | DataEdit[]): Promise<string>;
	/**
	 * Delete data records in a device using the profile token and device ID.
	 *
	 * See the example to understand how to use this method properly to have full control on what to delete.
	 *
	 * ! If query parameters are empty, last 15 data for the device will be deleted.
	 *
	 * @param deviceId Device ID.
	 * @param queryParams Parameters to specify what should be deleted on the device's data.
	 *
	 * @returns Success message indicating amount of records deleted (can be 0).
	 *
	 * @example
	 * ```ts
	 * await Resources.devices.deleteDeviceData("myDeviceId", { ids: ["recordIdToDelete", "anotherRecordIdToDelete" ] });
	 * ```
	 */
	deleteDeviceData(deviceId: GenericID, queryParams?: DataQuery): Promise<string>;
	/**
	 * Get Info of the Device Chunks.
	 * @experimental
	 * @param deviceID Device ID
	 */
	getChunk(deviceID: GenericID): Promise<DeviceChunkData[]>;
	/**
	 * Delete the chunk data.
	 * @experimental
	 * @param deviceID Device ID
	 * @param chunkID Chunk ID
	 */
	deleteChunk(deviceID: GenericID, chunkID: GenericID): Promise<string>;
	/**
	 * Schedule to export the Device Chunk's data to the TagoIO's files.
	 * @experimental
	 */
	copyChunk(params: DeviceChunkParams): Promise<DeviceChunkCopyResponse>;
}
export interface DictionaryCreateInfo {
	name: string;
	slug: string;
	fallback: string;
}
export interface DictionaryLanguage {
	code: string;
	active: boolean;
}
export interface DictionaryInfo extends DictionaryCreateInfo {
	id: GenericID;
	languages: DictionaryLanguage[];
	created_at: Date;
	updated_at: Date;
}
export interface LanguageData {
	[key: string]: string;
}
export interface LanguageEditData {
	dictionary: LanguageData;
	active: boolean;
}
export interface LanguageInfoQuery {
	fallback?: boolean;
}
export type DictionaryQuery = Query<DictionaryInfo, "name" | "slug" | "languages" | "fallback" | "created_at" | "updated_at">;
declare class Dictionaries extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieve a list with all dictionaries from an account.
	 *
	 * @default
	 * ```json
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name", "slug", "languages"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 * }
	 * ```
	 *
	 * @param queryObj Search query params.
	 */
	list(queryObj?: DictionaryQuery): Promise<DictionaryInfo[]>;
	/**
	 * Generate a new dictionary for the account.
	 *
	 * @param dictionaryObj Object with data to create new dictionary.
	 */
	create(dictionaryObj: DictionaryCreateInfo): Promise<{
		dictionary: string;
	}>;
	/**
	 * Modify any property of a dictionary.
	 *
	 * @param dictionaryID Dictionary ID.
	 * @param dictionaryObj Dictionary Object data to be replaced.
	 */
	edit(dictionaryID: GenericID, dictionaryObj: Partial<DictionaryCreateInfo>): Promise<string>;
	/**
	 * Delete a dictionary from the account.
	 *
	 * @param dictionaryID Dictionary ID.
	 */
	delete(dictionaryID: GenericID): Promise<string>;
	/**
	 * Get information about a dictionary.
	 *
	 * @param dictionaryID Dictionary ID.
	 */
	info(dictionaryID: GenericID): Promise<DictionaryInfo>;
	languageEdit(dictionaryID: GenericID, locale: string, languageObj: LanguageEditData): Promise<string>;
	/**
	 * Delete a language from a dictionary.
	 *
	 * @param dictionaryID Dictionary ID.
	 * @param locale Language locale string (e.g. `en-US`).
	 */
	languageDelete(dictionaryID: GenericID, locale: string): Promise<string>;
	/**
	 * Get information about a dictionary by ID.
	 *
	 * @param dictionaryID Dictionary ID.
	 * @param locale Language locale string (e.g. `en-US`).
	 * @param queryObj Language info query params.
	 */
	languageInfo(dictionaryID: GenericID, locale: string, queryObj?: LanguageInfoQuery): Promise<LanguageData>;
	/**
	 * Get information about a dictionary querying by slug instead of the dictionary's ID.
	 *
	 * @param slug Dictionary slug.
	 * @param locale Language locale string (e.g. `en-US`).
	 * @param queryObj Language info query params.
	 */
	languageInfoBySlug(slug: string, locale: string, queryObj?: LanguageInfoQuery): Promise<LanguageData>;
}
export interface FileQuery {
	path?: string;
	paginationToken?: string;
	quantity?: number;
}
export interface FileListInfo {
	files: {
		filename: string;
		size: number;
		last_modified: Date | null;
	}[];
	folders: string[];
}
export interface Base64File {
	/**
	 * Name of file
	 */
	filename: string;
	/**
	 * String of Base64
	 */
	file: string;
	/**
	 * Make file public
	 * default: false
	 */
	public?: boolean;
}
export interface CopyFiles {
	from: string;
	to: string;
}
export interface MoveFiles {
	from: string;
	to: string;
}
export interface FilesPermission {
	file: string;
	public: boolean;
}
export type UploadOptions = {
	/**
	 * the maximum amount of tries to upload each chunk to TagoIO. After this many unsuccessful tries of a single chunk, the upload is aborted
	 */
	maxTriesForEachChunk?: number;
	/**
	 * timeout before trying to upload the same chunk if the request failed
	 */
	timeoutForEachFailedChunk?: number;
	/**
	 * The file's content type. This is optional
	 */
	contentType?: string;
	/**
	 * if the file can be accessed by anybody with a link or not
	 */
	isPublic?: boolean;
	/**
	 * Dashboard ID.
	 *
	 * Uploading files from a widget requires `dashboard`, `widget`, and `fieldId` to be provided.
	 */
	dashboard?: string;
	/**
	 * Widget ID.
	 *
	 * Uploading files from a widget requires `dashboard`, `widget`, and `fieldId` to be provided.
	 */
	widget?: string;
	/**
	 * ID of the field from the widget where the file is selected.
	 *
	 * Uploading files from a widget requires `dashboard`, `widget`, and `fieldId` to be provided.
	 */
	fieldId?: string;
	/**
	 * will provide a cancel token for you to cancel the request
	 */
	onCancelToken?: (cancel: () => void) => any;
	/**
	 * the byte size of each chunk sent to TagoIO. This will influence how many requests this function will perform
	 */
	chunkSize?: number;
	/**
	 * will provide the upload percentage for this file
	 */
	onProgress?: (percentage: number) => any;
};
declare class Files extends TagoIOModule<GenericModuleParams> {
	/**
	 * list of files in account
	 * @param queryObj Object with path, pagination and quantity
	 */
	list(queryObj?: FileQuery): Promise<FileListInfo>;
	/**
	 * Upload an array of files(Base64) to TagoIO
	 * The filename parameter is also full path
	 * @param fileList Array of files data to be uploaded
	 * @example
	 * ```json
	 * fileList: [
	 *   {
	 *     filename: "/myfiles/myfile.ext",
	 *     file: "StringWithBase64"
	 *   }
	 * ]
	 * ```
	 */
	uploadBase64(fileList: Base64File[]): Promise<string>;
	/**
	 * Move/Rename Files
	 * @param fileList Array move actions to be made
	 * @example
	 * ```json
	 * fileList: [
	 *   {
	 *     from: "/myfiles/myOldName.ext",
	 *     to: "/myfiles/newFolder/andNewName.ext"
	 *   }
	 * ]
	 * ```
	 */
	move(fileList: MoveFiles[]): Promise<string>;
	/**
	 * Copy Files
	 * @param fileList Array of copy actions to be made
	 * @example
	 * ```json
	 * fileList: [
	 *   {
	 *     from: "/myfiles/myOldName.ext",
	 *     to: "/myfiles/newFolder/andNewName.ext"
	 *   }
	 * ]
	 * ```
	 */
	copy(fileList: CopyFiles[]): Promise<string>;
	/**
	 * Delete Folder or Files
	 * @param files An array of files or folders to be deleted
	 */
	delete(files: string[]): Promise<string>;
	/**
	 * Check if file is private or public
	 * @param file Path of file
	 */
	checkPermission(file: string): Promise<{
		public: boolean;
	}>;
	/**
	 * Change visibility from files
	 * @param filesVisibility An Array with files and their visibility to be setted
	 */
	changePermission(filesVisibility: FilesPermission[]): Promise<string>;
	private getPathFromUrl;
	/**
	 * Get a file url with authenticate token valid for 120 seconds
	 * @param url Full TagoIO File url
	 */
	getFileURLSigned(url: string): Promise<string>;
	/**
	 * Get file md5 with authenticate token for privates files
	 * @param url Full TagoIO File url
	 */
	getFileMD5(url: string): Promise<string>;
	/**
	 * Creates a multipart upload instance
	 * @param filename the path + filename for the file
	 * @param options the upload options for this file
	 */
	private createMultipartUpload;
	/**
	 * Uploads a single part to TagoIO
	 * @param filename the path + filename for the file
	 * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call
	 * @param partNumber the sequential part number for the upload. This should be 1 in the first call, then 2 in the second call, so on and so forth
	 * @param blob the portion of the file to be uploaded
	 * @param options the upload options for this file
	 */
	_uploadPart(filename: string, uploadID: string, partNumber: number, blob: Buffer | Blob, options?: UploadOptions): Promise<{
		ETag: string;
		PartNumber: number;
	}>;
	/**
	 * Adds an upload to the queue.
	 * It will try to upload for 'opts.maxTriesForEachChunk' and fail
	 * if it couldn't upload after those many tries.
	 * @param filename the path + filename for the file
	 * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call
	 * @param partNumberthe sequential part number for the upload. This should be 1 in the first call, then 2 in the second call, so on and so forth
	 * @param blob the portion of the file to be uploaded
	 * @param options see the uploadFile function
	 */
	_addToQueue(filename: string, uploadID: GenericID, partNumber: number, blob: Buffer | Blob, options?: UploadOptions): Promise<{
		ETag: string;
		PartNumber: number;
	}>;
	/**
	 * Finishes a multipart upload instance
	 * @param filename the path + filename for the file
	 * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call
	 * @param parts all the parts uploaded to the file
	 * @param options the upload options for this file
	 */
	_completeMultipartUpload(filename: string, uploadID: string, parts: {
		ETag: String;
		PartNumber: number;
	}[], options?: UploadOptions): Promise<{
		file: string;
	}>;
	/**
	 * Uploads a single file to TagoIO.
	 * The upload is multipart, meaning that the file will be divided and sent in chunks, resulting in multiple requests being made.
	 *
	 * @param file the file to be uploaded
	 * @param filename the path + filename for the file
	 * @param options the upload options for this file
	 */
	uploadFile(file: Buffer | Blob, filename: string, options?: UploadOptions): Promise<{
		file: string;
	}>;
	/**
	 * Throw a error if is cancelled
	 * @param cancelled
	 */
	private isCanceled;
}
export interface NotificationTriggerAnalysis {
	analysis_id: GenericID;
}
export interface NotificationTriggerHTTP {
	url: string;
	method: "POST" | "GET" | "PUT" | "DELETE" | "REDIRECT";
	body: {
		[key: string]: any;
	};
}
export interface NotificationTriggerProfile {
	share_profile: "accept" | "refuse";
}
export interface NotificationButton {
	id: string;
	label: string;
	color?: string;
	triggers: (NotificationTriggerAnalysis | NotificationTriggerHTTP | NotificationTriggerProfile)[];
}
export interface NotificationIconImage {
	image_url: string;
	bg_color?: HexColor;
	fit?: "fill" | "contain" | "cover";
}
export type HexColor = string;
export interface NotificationIconSVG {
	svg_url: string;
	svg_color?: HexColor;
	bg_color?: HexColor;
}
export interface NotificationCreate {
	title: string;
	message: string;
	read?: boolean;
	icon?: NotificationIconSVG | NotificationIconImage;
	buttons?: NotificationButton[];
	buttons_enabled?: boolean;
	buttons_autodisable?: boolean;
}
export type NotificationQuery = Query<{
	read: boolean;
}, "created_at">;
export type NotificationInfo = {
	id: GenericID;
	created_at: Date;
} & Required<NotificationCreate>;
declare class Notifications extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list with all actions from the account
	 * @param queryObj Search query params
	 */
	list(queryObj?: NotificationQuery): Promise<NotificationInfo[]>;
	/**
	 * Mark notifications as read
	 * @param notificationIDS An array of ids or a single id
	 */
	markAsRead(notificationIDS: GenericID[] | GenericID): Promise<string>;
	/**
	 * Mark notifications as unread
	 * @param notificationIDS An array of ids or a single id
	 */
	markAsUnread(notificationIDS: GenericID[] | GenericID): Promise<string>;
	/**
	 * Mark all notifications as read
	 */
	markAllAsRead(): Promise<string>;
	/**
	 * Acknowledge notification button pressed
	 * @param notificationID ID of the notification
	 * @param buttonID ID of the button
	 */
	notificationButton(notificationID: GenericID, buttonID: string): Promise<string>;
	/**
	 * Create a notification
	 * @param notificationData Notification Object
	 * @example
	 * ```json
	 * notificationData: [
	 *   {
	 *     title: "My notification title",
	 *     message: "My notification message"
	 *   }
	 * ]
	 * ```
	 */
	create(notificationData: NotificationCreate): Promise<{
		id: GenericID;
	}>;
	/**
	 * Remove a notification
	 * @param notificationID Notification identification
	 */
	remove(notificationID: GenericID): Promise<string>;
	/**
	 * Register device Token on Push Notification Service
	 * @param deviceToken Device token
	 * @param platform Platform of device
	 */
	registerDevice(deviceToken: GenericToken, platform: "ios" | "android"): Promise<string>;
	/**
	 * Unregister device Token on Push Notification Service
	 * @param deviceToken Device token
	 */
	unRegisterDevice(deviceToken: GenericToken): Promise<string>;
}
export interface PaymentInfo {
	status: boolean;
	result: [
		{
			id: GenericID;
			stripe_id: GenericID;
			account: GenericID;
			info: string;
			notes: string;
			invoice_number: number;
			invoice_code: string;
			total: number;
			due_date: string;
			payment_method: string;
			created_at: string;
			updated_at: string;
			paid: true;
			ref_account: {
				name: string;
				email: string;
				id: GenericID;
				send_invoice: boolean;
			};
			ref_payment_method: {
				last4: string;
				brand: string;
			};
			account_invoice_items: {
				unit_value: number;
				description: string;
				qty: number;
				value: number;
			}[];
		}
	];
}
declare class PaymentHistory extends TagoIOModule<GenericModuleParams> {
	/**
	 * Get the payment History of the current account
	 */
	getHistory(): Promise<PaymentInfo[]>;
}
export interface PaymentMethodCreateInfo {
	name: string;
	token: GenericToken;
	brand?: string;
	default_card?: boolean;
}
export interface PaymentMethodInfo extends PaymentMethodCreateInfo {
	id: GenericID;
	last4: string;
	active: boolean;
	default_card: boolean;
	exp_month: string;
	exp_year: string;
}
declare class PaymentMethods extends TagoIOModule<GenericModuleParams> {
	create(paymentMethodData: PaymentMethodCreateInfo): Promise<PaymentMethodInfo[]>;
	list(): Promise<PaymentMethodInfo[]>;
	setDefault(paymentMethodID: GenericID): Promise<string>;
	delete(paymentMethodID: GenericID): Promise<string>;
}
export interface PlanSetInfo {
	plan: string;
	sms?: number;
	email?: number;
	data_records?: number;
	device_request?: number;
	analysis?: number;
}
export interface PlanInfo extends PlanSetInfo {
	id: GenericID;
	active: number;
	end_date: Date | null;
	price: number;
	created_at: Date;
	next_plan: string;
}
export interface ProfileLimit {
	id: GenericID;
	name: string;
	limits: {
		input: number;
		output: number;
		sms: number;
		email: number;
		analysis: number;
		data_records: number;
	};
	addons: object;
}
export interface Discount {
	description: string;
	value: number;
	expire_at: ExpireTimeOption;
}
export interface Summary {
	profiles: ProfileLimit[];
	plan: string;
	discounts: Discount[];
}
export interface Price {
	price: number;
	amount: number;
}
export interface CurrentPrices {
	analysis: Price[];
	data_records: Price[];
	sms: Price[];
	output: Price[];
	input: Price[];
	email: Price[];
	plans: {
		name: string;
		price: number;
	}[];
	addons: {
		name: string;
		price: number;
	}[];
}
declare class Plan extends TagoIOModule<GenericModuleParams> {
	/**
	 * Active plan and set services limit
	 * @param data
	 * @example
	 * data: {
	 *   "plan": "plan_id",
	 *   "sms": 100,
	 *   "email": 1000,
	 *   "data_records": 200000,
	 *   "device_request": 250,
	 *   "analysis": 1000
	 * }
	 */
	setPlanParameters(data: PlanSetInfo): Promise<string>;
	/**
	 * Get Active Plan and Services
	 */
	getActivePlan(): Promise<PlanInfo>;
	/**
	 * Shows a summary of how much your account is costing, divided by sections
	 */
	summary(): Promise<Summary>;
	/**
	 * Get current Tago pricing
	 */
	getCurrentPrices(): Promise<CurrentPrices>;
}
export interface ProfileListInfo {
	id: GenericID;
	name: string;
	logo_url: string | null;
}
export interface ProfileLimit {
	input: number;
	output: number;
	sms: number;
	email: number;
	analysis: number;
	data_records: number;
	run_users: number;
	push_notification: number;
	file_storage: number;
}
export type ProfileAddOns = {
	/**
	 * Whether the profile has the Custom Domain add-on purchased.
	 */
	custom_dns: boolean;
	/**
	 * Whether the profile has the Custom Mobile App add-on purchased.
	 */
	mobile: boolean;
};
export interface ProfileInfo {
	info: {
		id: GenericID;
		account: GenericID;
		name: string;
		logo_url: string | null;
		banner_url: string | null;
		created_at: Date;
		updated_at: Date;
	};
	allocation: ProfileLimit;
	addons: ProfileAddOns;
	account_plan: string;
}
export interface ProfileSummary {
	limit: ProfileLimit;
	amount: {
		device: number;
		bucket: number;
		dashboard: number;
		dashboard_shared: number;
		analysis: number;
		action: number;
		am: number;
		run_users: number;
		dictionary: number;
		connectors: number;
		networks: number;
		tcore: number;
	};
	limit_used: {
		input: number;
		output: number;
		analysis: number;
		sms: number;
		email: number;
		data_records: number;
		run_users: number;
		push_notification: number;
		file_storage: number;
		tcore: number;
	};
	addons: ProfileAddOns;
}
/**
 * Type for a single usage statistic with timestamp.
 *
 * Not all of the services will be present for every statistic, only if for the usage period the service was used.
 */
export type UsageStatistic = Partial<Record<BillingService, number>> & {
	/**
	 * Timestamp for the usage statistic.
	 */
	time: Date;
};
export interface AuditLog {
	events?: {
		resourceName: string;
		message: string;
		resourceID: GenericID;
		who: GenericID;
		date: Date;
	}[];
	statistics?: {
		recordsMatched: number;
		recordsScanned: number;
		bytesScanned: number;
	};
	status?: "Running" | "Complete" | "Failed" | "Timeout" | "Unknown";
	queryId: string;
}
export type resourceNameType = "action" | "am" | "analysis" | "connector" | "dashboard" | "device" | "dictionary" | "network" | "profile" | "run" | "runuser";
export interface AuditLogFilter {
	resourceID?: GenericID;
	resourceName?: resourceNameType;
	find?: "*" | string;
	start_date?: Date;
	end_date?: Date;
	limit?: number;
}
export interface AddonInfo {
	id: GenericID;
	name: string;
	logo_url: string | null;
}
export type DateFixed = {
	/**
	 * Timestamp for fetching the hourly statistics in a day.
	 */
	date?: string | Date | undefined;
};
export type DateRange = {
	/**
	 * Starting date for fetching statistics in a interval.
	 */
	start_date: string | Date;
	/**
	 * End date for fetching statistics in a interval.
	 */
	end_date: string | Date;
	/**
	 * Periodicity of the statistics to fetch.
	 *
	 * @default "hour"
	 */
	periodicity: "hour" | "day" | "month";
};
export type StatisticsDate = {
	/**
	 * Timezone to be used in the statistics entries.
	 *
	 * @default "UTC"
	 */
	timezone?: string;
} & (DateFixed | DateRange);
export type ProfileTeam = {
	active: boolean;
	created_at: Date;
	email: string;
	id: string;
	name: string;
};
declare class Profile extends TagoIOModule<GenericModuleParams> {
	/**
	 * Lists all the profiles in your account
	 */
	list(): Promise<ProfileListInfo[]>;
	/**
	 * Get Profile info
	 * @param profileID Profile identification or "current" for current profile
	 * example:
	 * - Resources.profiles.info("6126850f58ef8600184dd486");
	 * - Resources.profiles.info("current");
	 */
	info(profileID: GenericID | "current"): Promise<ProfileInfo>;
	/**
	 * Gets profile summary
	 */
	summary(profileID: GenericID): Promise<ProfileSummary>;
	/**
	 * Create a profile.
	 *
	 * If `allocate_free_resources` is passed as an option, all the free resources available
	 * in allocation will be allocated to the new profile.
	 *
	 * @param profileObj Profile object with data to be created
	 * @param options Options for the created profile.
	 */
	create(profileObj: {
		name: string;
	}, options?: {
		allocate_free_resources?: boolean;
	}): Promise<{
		id: GenericID;
	}>;
	/**
	 * Edits a profile
	 * @param profileObj Profile object with data to be changed
	 */
	edit(profileID: GenericID, profileObj: Partial<ProfileInfo>): Promise<string>;
	/**
	 * Delete profile
	 * @param profileID Profile identification
	 */
	delete(profileID: GenericID): Promise<string>;
	/**
	 * List all the usage statistics of a profile.
	 *
	 * Usage statistics are cumulative: if a service was not used in a time period,
	 * the statistics for that time period will not be in the object.
	 *
	 * @param profileID Profile identification
	 * @param dateObj Object with date and their timezone
	 *
	 * @returns Array of cumulative usage statistics.
	 *
	 * @example
	 *
	 * ```json
	 * [
	 *   { "time": "2022-01-01T00:00:00.000Z", "input": 5 },
	 *   { "time": "2022-01-02T00:00:00.000Z", "input": 5, "output": 10 },
	 *   { "time": "2022-01-03T00:00:00.000Z", "input": 10, "output": 15 },
	 * ]
	 * ```
	 */
	usageStatisticList(profileID: GenericID, dateObj?: StatisticsDate): Promise<UsageStatistic[]>;
	/**
	 * Create a query for auditlog
	 * @param profileID Profile identification
	 * @param filterObj auditlog filter object
	 */
	auditLog(profileID: GenericID, filterObj?: AuditLogFilter): Promise<AuditLog>;
	/**
	 * Fetches the information from an auditlog query
	 * @param profileID Profile identification
	 * @param queryId auditlog queryId from auditLogCreate
	 */
	auditLogQuery(profileID: GenericID, queryId?: string): Promise<AuditLog>;
	/**
	 * Gets the information of addons for the profile
	 * @param profileID Profile identification
	 */
	addonList(profileID: GenericID): Promise<AddonInfo>;
	/**
	 * Sets the information of addons for the profile
	 * @param profileID Profile identification
	 * @param addonObj
	 */
	addonEdit(profileID: GenericID, addonObj: Partial<AddonInfo>): Promise<string>;
	/**
	 * Sets the information of services for the profile. Services are the main resources
	 * in your profile, for example data input, data output, etc...
	 * @param profileID Profile identification
	 * @param serviceObj
	 */
	serviceEdit(profileID: GenericID, serviceObj: object): Promise<string>;
	/**
	 * Transforms the current token to another profile. The current profile will
	 * no longer have the current token, as the current token will be acquired by the profile informed.
	 * After this call is done, other requests using this token will work solely for the new profile, and
	 * no longer for the current profile.
	 * @param targetProfileID Profile identification
	 */
	transferTokenToAnotherProfile(targetProfileID: GenericID): Promise<string>;
	/**
	 * Retrieves a list of all tokens
	 * @param profileID Profile ID
	 * @param queryObj Search query params
	 */
	tokenList(profileID: GenericID, queryObj?: ListTokenQuery): Promise<Partial<TokenDataList>[]>;
	/**
	 * Generates and retrieves a new token
	 * @param profileID Profile ID
	 * @param tokenParams Token params for new token
	 */
	tokenCreate(profileID: GenericID, tokenParams: TokenData): Promise<TokenCreateResponse>;
	/**
	 * Deletes a token
	 * @param token Token
	 */
	tokenDelete(token: GenericToken): Promise<string>;
	/**
	 * Remove an add-on from a profile at the end of the billing cycle.
	 *
	 * @throws If profile ID is invalid.
	 * @throws If profile doesn't have the add-on.
	 *
	 * @returns Success message.
	 */
	removeAddOn(profileId: GenericID, addon: BillingAddOn): Promise<string>;
	/**
	 * Add a team member to a profile in a specific account
	 *
	 * @throws If the email is not a valid TagoIO's account.
	 * @throws If the profile does not exists.
	 *
	 * @returns Success message.
	 */
	addTeamMember(id: string, email: string): Promise<string>;
	/**
	 * Fetch the list of accounts that a profile is shared with.
	 */
	teamList(id: string): Promise<ProfileTeam[]>;
	/**
	 * Remove an account from a profile shared team.
	 *
	 * @throws If the accountId is not a valid TagoIO's account.
	 * @throws If the profile does not exists.
	 *
	 * @returns Success message.
	 */
	deleteTeamMember(id: string, accountId: string): Promise<string>;
}
export interface RunInfo {
	profile: GenericID;
	active: boolean;
	name: string;
	sub_title: string;
	url: string;
	email_domain: string | null;
	signup_method: string;
	favicon: string | null;
	logo: string | null;
	signup_logo: string | null;
	signup_logo_options: object;
	sidebar_buttons: {
		color: string;
		href: string;
		iconUrl: string;
		text: string;
		type: string;
		value?: string;
	}[];
	signup_fields: {
		name: string;
		placeholder: string;
		required: boolean;
		type: string;
	}[];
	email_templates: {
		[email_template_key: string]: {
			subject: string;
			value: string;
		};
	};
	feature_devicewifisetup: {
		background_color: string;
		button_cancel_background_color: string;
		button_cancel_text_color: string;
		button_confirm_background_color: string;
		button_confirm_text_color: string;
		enabled: boolean;
		ip: string;
		language: string;
		name: string;
		port: string;
		protocol: string;
		text_color: string;
		translations: {
			[language: string]: object;
		};
	};
	feature_geolocation: {
		buffer_size: number;
		device: string | null;
		enabled: boolean;
		middleware_url: string;
		minimum_distance: number;
		minimum_interval: number;
		target: string;
	};
	theme: {
		[option in ThemeOption]: string;
	};
	integration: object;
	sso_saml_active: boolean;
	security: {
		otp: {
			authenticator: boolean;
			sms: boolean;
			email: boolean;
		};
	};
	signin_buttons: {
		label: string;
		type: "link";
		url: string;
	}[];
	anonymous_token: string;
	auth_token_ttl: string;
	dictionary: GenericID;
}
export interface UserCreateInfo {
	name: string;
	email: string;
	password: string;
	timezone: string;
	company?: string;
	phone?: string;
	language?: string;
	tags?: TagsObj[];
	active?: boolean;
}
export interface UserCreateResponse {
	user: GenericID;
}
export interface UserInfo extends Omit<UserCreateInfo, "password"> {
	id: GenericID;
	profile: GenericID;
	active: boolean;
	newsletter: boolean;
	last_login: Date | null;
	created_at: Date;
	updated_at: Date;
	options: object;
	tags: TagsObj[];
}
export interface LoginResponseRun {
	token: GenericToken;
	expire_date: ExpireTimeOption;
}
export interface LoginAsUserOptions {
	/**
	 * Date to expire the login token.
	 *
	 * @example
	 * "3 months", "1 year", "20 hours"
	 * @default "8 hours"
	 */
	expire_time?: string;
}
export interface SAMLAttributeMappings {
	email: string;
	firstName: string;
	lastName?: string;
	phone?: string;
	company?: string;
	language?: string;
	timezone?: string;
	tags?: {
		[tag: string]: string;
	};
}
export interface RunSAMLInfo {
	/**
	 * Information for TagoIO's API routes to use as a Service Provider in SAML authentication flows.
	 */
	sp: {
		entity_id: string;
		acs_url: string;
		metadata: string;
	};
	/**
	 * Relevant information from the Identity Provider's metadata after being parsed by TagoIO.
	 */
	idp: {
		issuer: string;
	};
	/**
	 * Attribute mappings for the Identity Provider's attributes to the attributes used in TagoIO.
	 */
	mapping: SAMLAttributeMappings;
}
export interface RunSAMLEditInfo {
	/**
	 * Identity Provider's XML metadata encoded in a base 64 string.
	 */
	idp_metadata?: string;
	/**
	 * Attribute mappings for the Identity Provider's attributes to the attributes used in TagoIO.
	 */
	mapping?: SAMLAttributeMappings;
}
export type CustomDomainDnsRecord = {
	/**
	 * Status for the DNS record check.
	 *
	 * When `true`, the DNS record is properly configured with the provided key and value.
	 * When `false`, the DNS record is either not yet configured or the `key` exists but the
	 * value in the DNS record does not match the `value` provided.
	 */
	status: boolean;
	/**
	 * Type of the DNS record.
	 */
	type: string;
	/**
	 * Key for key-value pair in the DNS record.
	 */
	key: string;
	/**
	 * Value for the key-value pair the DNS record.
	 */
	value: string;
	/**
	 * Current value in the provider's record for the DNS record's `key`.
	 *
	 * Only returned when the DNS record has the matching `key` configured.
	 *
	 * When `status` is `true`, the value here will be the same as the one in `value`.
	 * When `status` is `false`, the value here can is either stale or there was an error
	 * copying the provided `value` in the DNS provider's record.
	 */
	current_value?: string;
};
/**
 * Type for the Custom Domain response from the API, unparsed.
 *
 * @internal
 */
export interface CustomDomainResponse {
	/**
	 * Whether the custom domain is active.
	 *
	 * This is only `true` when all the required DNS records are properly configured in the DNS provider.
	 */
	active: boolean;
	/**
	 * Configured domain for the RUN.
	 */
	domain: string;
	/**
	 * Configured subdomain for the RUN.
	 */
	subdomain: string;
	/**
	 * Mailing address for the RUN with custom domain.
	 */
	email: string;
	/**
	 * DNS record for the SSL certificate.
	 *
	 * The information in this record needs to be configured in the DNS provider for the custom domain.
	 */
	dns_ssl: CustomDomainDnsRecord;
	/**
	 * DNS record for the page endpoint.
	 *
	 * The information in this record needs to be configured in the DNS provider for the custom domain.
	 */
	dns_page: CustomDomainDnsRecord;
	/**
	 * First DNS record for the e-mail.
	 *
	 * The information in this record needs to be configured in the DNS provider for the custom domain.
	 */
	dns_email_1: CustomDomainDnsRecord;
	/**
	 * Second DNS record for the e-mail.
	 *
	 * The information in this record needs to be configured in the DNS provider for the custom domain.
	 */
	dns_email_2: CustomDomainDnsRecord;
	/**
	 * Third DNS record for the e-mail.
	 *
	 * The information in this record needs to be configured in the DNS provider for the custom domain.
	 */
	dns_email_3: CustomDomainDnsRecord;
	/**
	 * Timestamp (in string format) for when the custom domain was configured.
	 */
	created_at: string;
}
/**
 * Type for the Custom Domain information in a profile's RUN.
 */
export interface CustomDomainInfo extends Omit<CustomDomainResponse, "created_at"> {
	/**
	 * Timestamp for when the custom domain was configured.
	 */
	created_at: Date;
}
/**
 * Type for the data required to configure a profile's RUN Custom Domain.
 */
export interface CustomDomainCreate {
	/**
	 * Domain for the RUN's custom domain.
	 *
	 * If the desired custom domain is `portal.mycompany.com`, this will be `"mycompany.com"`.
	 */
	domain: string;
	/**
	 * Subdomain for the RUN's custom domain.
	 *
	 * If the desired custom domain is `portal.mycompany.com`, this will be `"portal"`.
	 */
	subdomain: string;
	/**
	 * Mailing address for the RUN with custom domain.
	 *
	 * If the desired custom domain is `portal.mycompany.com`, this can be either
	 * `"portal.mycompany.com"` or `"mycompany.com"`.
	 */
	email: string;
}
export type ThemeOption = "actionSchedule" | "actionTriggerByData" | "actionTriggerByResource" | "actionTriggerByMQTT" | "alertDangerBackground" | "alertInfoBackground" | "alertWarningBackground" | "analysisExternal" | "analysisInternal" | "buttonDanger" | "buttonDangerText" | "buttonDefault" | "buttonDefaultText" | "buttonDisabled" | "buttonDisabledText" | "buttonIconLabel" | "buttonPrimary" | "buttonPrimaryText" | "buttonSuccess" | "buttonSuccessText" | "buttonWarning" | "buttonWarningText" | "deviceInputOutput1Day" | "deviceInputOutput3Days" | "deviceInputOutput3Hours" | "deviceInputOutput6Hours" | "deviceInputOutputRest" | "dottedBorder" | "dropdownAccent" | "dropdownBackground" | "floatingSidebarTitle" | "footerBackground" | "formControlBorder" | "gaugeEmpty" | "gaugeFill" | "gaugePrimaryText" | "gaugeSecondaryText" | "iconRadioSelected" | "iconRadioSubTitle" | "informationIcon" | "inputBackground" | "inputBackgroundReadOnly" | "inputError" | "inputForeground" | "inputForegroundReadOnly" | "lightBorder" | "limitAlert" | "link" | "listNavColor" | "listTitleLabel" | "loading" | "loginButton" | "loginButtonText" | "loginForeground" | "loginForm" | "modalContainer" | "modalOverlay" | "navbar" | "navbarBetaDeveloperBorder" | "navbarButton" | "navbarDropdownBorder" | "navbarDropdownOption" | "navbarDropdownOptionBorder" | "navbarText" | "navDescription" | "notificationButtonAmount" | "notificationButtonAmountText" | "notificationFilterBackground" | "notificationFooter" | "notificationItemBorder" | "notificationItemDate" | "notificationItemTextAccepted" | "notificationItemUnread" | "primary" | "publicPageNavigationBar" | "sidebarAccessSelected" | "sidebarAccountSelected" | "sidebarActionSelected" | "sidebarAnalysisSelected" | "sidebarBackground" | "sidebarBillingSelected" | "sidebarBucketSelected" | "sidebarDashboardSelected" | "sidebarDeviceSelected" | "sidebarExploreSelected" | "sidebarFileSelected" | "sidebarForegroundIcon" | "sidebarForegroundText" | "sidebarHomeSelected" | "sidebarItem" | "sidebarRibbon" | "sidebarRunSelected" | "sidebarSeparator" | "sidebarSeparatorForeground" | "sidebarUserSelected" | "snakeButtonOutline" | "svgTagoFont" | "svgTagoIOHole" | "switchDisabledBackground" | "switchSlider" | "tabBackground" | "tabLabelBorder" | "tooltipContainer" | "tooltipText" | "verticalTabItem" | "verticalTabItemBorder" | "widgetCardBackground" | "widgetIconsAccent" | "widgetIconsBackground" | "widgetIconsColor" | "widgetIconsFooterBasic" | "widgetIconsFooterPremium" | "auth_bg_opacity" | "auth_bg_src" | "auth_bg_type" | "auth_form_opacity";
export type UserQuery = Query<UserInfo, "name" | "active" | "last_login" | "created_at" | "updated_at">;
declare class Run extends TagoIOModule<GenericModuleParams> {
	info(): Promise<RunInfo>;
	edit(data: RecursivePartial<RunInfo>): Promise<string>;
	listUsers(query: UserQuery): Promise<Partial<UserInfo>[]>;
	userInfo(userID: GenericID): Promise<UserInfo>;
	userCreate(data: UserCreateInfo): Promise<UserCreateResponse>;
	userEdit(userID: GenericID, data: Partial<UserInfo>): Promise<string>;
	userDelete(userID: GenericID): Promise<string>;
	loginAsUser(userID: GenericID, options?: LoginAsUserOptions): Promise<LoginResponseRun>;
	emailTest(data: {
		subject: string;
		body: string;
	}): Promise<string>;
	notificationList(userID: GenericID): Promise<NotificationInfo[]>;
	notificationCreate(userID: GenericID, data: NotificationCreate): Promise<{
		id: GenericID;
	}>;
	notificationEdit(notificationID: GenericID, data: Partial<NotificationCreate>): Promise<string>;
	notificationDelete(notificationID: GenericID): Promise<string>;
	/**
	 * Get the SAML Single Sign-On information for the account's RUN.
	 */
	ssoSAMLInfo(): Promise<RunSAMLInfo>;
	/**
	 * Edit the SAML Single Sign-On metadata and mappings for the account's RUN.
	 *
	 * @param data Updated data for a RUN's SAML Single Sign-On configuration.
	 */
	ssoSAMLEdit(data: RunSAMLEditInfo): Promise<string>;
	/**
	 * Create a TagoRUN custom domain for the profile.
	 *
	 * @param profile_id ID of the profile
	 * @param customDomainData query params
	 * @returns Success message.
	 */
	createCustomDomain(profile_id: string, customDomainData: CustomDomainCreate): Promise<string>;
	/**
	 * Get details of TagoRun custom domain for the profile.
	 *
	 * @param profile_id ID of the profile
	 * @returns Data for the profile's custom DNS configuration.
	 */
	getCustomDomain(profile_id: string): Promise<CustomDomainInfo>;
	/**
	 * delete a TagoRUN custom domain for the profile.
	 *
	 * @param profile_id ID of the profile
	 * @returns Success message.
	 */
	deleteCustomDomain(profile_id: string): Promise<string>;
	/**
	 * Regenerate a TagoRUN custom domain for the profile.
	 *
	 * @param profile_id ID of the profile
	 * @returns Success message.
	 */
	regenerateCustomDomain(profile_id: string): Promise<string>;
}
declare class ServiceAuthorization extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list of all tokens
	 * @example
	 * Default Query: {
	 *   page: 1,
	 *   fields: ["name", "token", "permission"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "created_at,desc",
	 * }
	 * @param query Search query params
	 */
	tokenList(query?: ListTokenQuery): Promise<Partial<TokenDataList>[]>;
	/**
	 * Generates and retrieves a new token
	 * @param tokenParams Token params to create new token
	 */
	tokenCreate(tokenParams: TokenData): Promise<TokenCreateResponse>;
	/**
	 * Deletes a token
	 * @param token Token
	 */
	tokenDelete(token: GenericToken): Promise<string>;
	tokenEdit(token: GenericToken, verificationCode?: string): Promise<string>;
}
export type TagTypes = "bucket" | "device" | "dashboard" | "action" | "analysis" | "tcore";
declare class Tags extends TagoIOModule<GenericModuleParams> {
	/**
	 * Get all Keys from certain type of section
	 * @param type List to get the array of tags keys.
	 * It can be: bucket, device, dashboard, action, analysis
	 */
	getTagKeys(type: TagTypes): Promise<string[]>;
}
export interface TemplateObjDashboard {
	dashboard: GenericID;
	name: string;
	image_logo?: string;
	image_main?: string;
	/**
	 * Dashboard Setup Object
	 */
	setup?: any;
}
export interface TemplateObjAnalysis {
	analysis: GenericID;
	name: string;
	image_logo?: string;
	image_main?: string;
	/**
	 * Analysis Setup Object
	 */
	setup?: any;
}
export interface TemplateInstallDashboard {
	device?: {
		id: GenericID;
		bucket: GenericID;
	} | void;
	devices?: {
		id: GenericID;
		bucket: GenericID;
	} | void;
	analysis?: GenericID[] | void;
	replace?: {
		[field: string]: any;
	} | void;
}
export interface TemplateInstallAnalysis {
	device_token?: string;
	replace?: {
		[field: string]: any;
	} | void;
}
export interface TemplateObj {
	name: string;
	type: "dashboard" | "analysis";
	image_main?: string;
	image_logo?: string;
	updated_at: Date;
	created_at: Date;
}
export interface TemplateInstallReturn {
	dashboard?: string;
	analysis?: string;
}
export type TemplateInstallParams = TemplateInstallDashboard | TemplateInstallAnalysis;
declare class Template extends TagoIOModule<GenericModuleParams> {
	generateTemplate(template: TemplateObjDashboard | TemplateObjAnalysis): Promise<string>;
	installTemplate(templateID: GenericID, installParams?: TemplateInstallParams): Promise<TemplateInstallReturn>;
	getTemplate(templateID: GenericID): Promise<TemplateObj>;
}
export interface IDeviceParameters {
	name?: string;
	label?: string;
	type?: "text" | "dropdown" | "switch" | "number";
	default?: any;
	group?: "default" | "main" | "advanced" | "hide";
	options?: any[];
}
export interface ConnectorCreateInfo {
	name?: string;
	description?: string;
	logo_url?: string;
	device_parameters?: IDeviceParameters[];
	networks?: string[];
	payload_decoder?: string;
	install_text?: string;
	install_end_text?: string;
	device_annotation?: string;
}
export interface ConnectorInfo extends ConnectorCreateInfo {
	id: GenericID;
	public: boolean;
	description?: string;
	logo_url?: string;
	created_at: Date;
	updated_at: Date;
	device_parameters?: IDeviceParameters[];
	networks?: string[];
	install_text?: string;
	install_end_text?: string;
	device_annotation?: string;
}
export type ConnectorQuery = Query<ConnectorInfo, "name" | "id" | "description" | "logo_url" | "install_text" | "install_end_text" | "device_annotation" | "payload_decoder" | "networks">;
declare class Connectors extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list with all connectors from account
	 * @default
	 * ```json
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 * }
	 * ```
	 * @param queryObj Search query params
	 */
	list(queryObj?: ConnectorQuery): Promise<ConnectorInfo[]>;
	/**
	 * Get Info of the Connector
	 * @param connectorID Connector identification
	 * @param fields Fields to fetch.
	 */
	info(connectorID: GenericID, fields?: string[]): Promise<ConnectorInfo>;
	/**
	 * Generates and retrieves a new connector from the account
	 * @param connectorObj Object data to create new Connector
	 */
	create(connectorObj: ConnectorCreateInfo): Promise<{
		connector: GenericID;
	}>;
	/**
	 * Modify any property of the connector
	 * @param connectorID Connector identification
	 * @param connectorObj Object data to create new Connector
	 */
	edit(connectorID: GenericID, connectorObj: Partial<ConnectorCreateInfo>): Promise<string>;
}
export interface IDeviceParameters {
	name?: string;
	label?: string;
	type?: "text" | "dropdown" | "switch" | "number";
	default?: any;
	group?: "default" | "main" | "advanced" | "hide";
	options?: any[];
}
export interface NetworkCreateInfo {
	name?: string;
	description?: string;
	logo_url?: string;
	icon_url?: string;
	banner_url?: string;
	device_parameters?: IDeviceParameters[];
	middleware_endpoint?: string;
	payload_encoder?: string;
	payload_decoder?: string;
	public?: boolean;
	documentation_url?: string;
	serial_number?: {
		mask?: string;
		label?: string;
		image?: string;
		case?: string;
		help?: string;
		required?: boolean;
	};
	require_devices_access?: boolean;
}
export interface NetworkInfo extends NetworkCreateInfo {
	id: GenericID;
	name?: string;
	description?: string;
	logo_url?: string;
	icon_url?: string;
	banner_url?: string;
	device_parameters?: IDeviceParameters[];
	middleware_endpoint?: string;
	payload_encoder?: string;
	payload_decoder?: string;
	public?: boolean;
	documentation_url?: string;
	serial_number?: {
		mask?: string;
		label?: string;
		image?: string;
		case?: string;
		help?: string;
		required?: boolean;
	};
}
export interface NetworkTokenInfo extends TokenData {
	created_at: Date;
	updated_at: Date;
	Network: GenericID;
	type: "type" | "Network";
}
export type NetworkQuery = Query<NetworkInfo, "name" | "description" | "logo_url" | "icon_url" | "banner_url" | "device_parameters" | "middleware_endpoint" | "payload_encoder" | "payload_decoder" | "serial_number" | "documentation_url" | "public" | "created_at" | "updated_at">;
declare class Networks extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list with all Networks from account
	 * @default
	 * ```json
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 * }
	 * ```
	 * @param queryObj Search query params
	 */
	list(queryObj?: NetworkQuery): Promise<NetworkInfo[]>;
	/**
	 * Get Info of the Network
	 * @param networkID Network identification
	 * @param fields Fields to fetch.
	 */
	info(networkID: GenericID, fields?: string[]): Promise<NetworkInfo>;
	/**
	 * Generates and retrieves a new network from the account
	 * @param connectorObj Object data to create new Network
	 */
	create(connectorObj: NetworkCreateInfo): Promise<{
		network: GenericID;
	}>;
	/**
	 * Modify any property of the network
	 * @param networkID Network identification
	 * @param connectorObj Object data to create new Network
	 */
	edit(networkID: GenericID, connectorObj: Partial<NetworkCreateInfo>): Promise<string>;
	/**
	 * Retrieves a list of all tokens
	 * @default
	 * ```json
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["name", "token", "permission"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "created_at,desc",
	 * }
	 * ```
	 * @param networkID Network ID
	 * @param queryObj Search query params
	 */
	tokenList(networkID: GenericID, queryObj?: ListTokenQuery): Promise<Partial<NetworkTokenInfo>[]>;
	/**
	 * Generates and retrieves a new token
	 * @param networkID Network ID
	 * @param tokenParams Details of new token
	 */
	tokenCreate(networkID: GenericID, tokenParams: TokenData): Promise<TokenCreateResponse>;
	/**
	 * Deletes a token
	 * @param token Token ID
	 */
	tokenDelete(token: GenericToken): Promise<string>;
}
declare class Integration extends TagoIOModule<GenericModuleParams> {
	connectors: Connectors;
	networks: Networks;
}
export interface TagoCoreComputerUsage {
	total: number;
	used: number;
	description: string;
	title: string;
	type: string;
	detail: string;
}
export interface TagoCoreOS {
	name: string;
	arch: string;
	version: string;
	platform?: string;
}
export interface TagoCoreSummary {
	device: number;
	action: number;
	analysis: number;
}
export interface TagoCoreInfo {
	active: boolean;
	computer_usage: TagoCoreComputerUsage[];
	connected: boolean;
	created_at: string;
	id: GenericID;
	internet_ip: string;
	last_connection: string;
	local_ips: string;
	name: string;
	os: TagoCoreOS;
	profile: string;
	summary: TagoCoreSummary;
	system_start_time: string;
	tags: TagsObj[];
	tcore_start_time: string;
	tcore_version: string;
	token: GenericToken;
	updated_at: string;
	machine_id: string;
	cluster: string;
}
export interface TagoCoreListInfo {
	active: boolean;
	connected: boolean;
	created_at: string;
	id: GenericID;
	internet_ip: string;
	last_connection: string;
	local_ips: string;
	name: string;
	profile: string;
	system_start_time: string;
	tags: TagsObj[];
	tcore_start_time: string;
	tcore_version: string;
	updated_at: string;
	machine_id: string;
	cluster: string;
}
export type TagoCoreQuery = Query<TagoCoreInfo, "name" | "active" | "created_at" | "updated_at" | "last_connection" | "local_ips" | "internet_ip" | "system_start_time" | "tcore_start_time" | "machine_id">;
export interface TagoCoreClusterListInfo {
	created_at: string;
	id: GenericID;
	name: string;
	profile: string;
	tags: TagsObj[];
	instance_amount: number;
	updated_at: string;
}
export interface TagoCoreClusterInfo {
	created_at: string;
	id: GenericID;
	name: string;
	profile: string;
	tags: TagsObj[];
	instance_amount: number;
	token: string;
	updated_at: string;
	state: string;
}
export interface TagoCoreClusterCreateInfo {
	name: string;
}
export type TagoCoreClusterQuery = Query<TagoCoreClusterInfo, "name" | "created_at" | "updated_at">;
declare class TagoCores extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a list with all TagoCores from the account
	 * @default
	 * ```json
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 * }
	 * ```json
	 * @param queryObj Search query params
	 */
	list(queryObj?: TagoCoreQuery): Promise<TagoCoreListInfo[]>;
	/**
	 * Gets information about the TagoCore
	 * @param tagoCoreID TagoCore ID
	 * @param summary Fetch summary from the instance if it is connected
	 */
	info(tagoCoreID: GenericID, summary?: boolean): Promise<TagoCoreInfo>;
	/**
	 * Modify any property of the TagoCore.
	 * @param tagoCoreID TagoCore ID
	 * @param tagoCoreObj TagoCore Object with data to replace
	 */
	edit(tagoCoreID: GenericID, tagoCoreObj: Partial<TagoCoreInfo>): Promise<string>;
	/**
	 * Generate a new token for the TagoCore
	 * @param tagoCoreID TagoCore ID
	 */
	tokenGenerate(tagoCoreID: GenericID): Promise<string>;
	/**
	 * Deletes a TagoCore
	 * @param tagoCoreID TagoCore ID
	 */
	delete(tagocoreID: GenericID): Promise<string>;
	/**
	 * Retrieves a list with all TagoCore Clusters from the account
	 * @default
	 * ```json
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 * }
	 * ```json
	 * @param queryObj Search query params
	 */
	clusterList(queryObj?: TagoCoreClusterQuery): Promise<TagoCoreClusterListInfo[]>;
	/**
	 * Generate a new token for the TagoCore
	 * @param clusterID TagoCore Cluster ID
	 */
	clusterTokenCreate(clusterID: GenericID): Promise<string>;
	/**
	 * Gets information about the TagoCore Cluster
	 * @param clusterID TagoCore Cluster ID
	 */
	clusterInfo(clusterID: GenericID): Promise<TagoCoreClusterInfo>;
	/**
	 * Modify any property of the TagoCore Cluster.
	 * @param clusterID TagoCore Cluster ID
	 * @param updateObj TagoCore Cluster Object with data to replace
	 */
	clusterEdit(clusterID: GenericID, updateObj: Partial<TagoCoreClusterInfo>): Promise<string>;
	/**
	 * Generates and retrieves a new Cluster for the account
	 * @param clusterObj Object with data to create new bucket
	 */
	clusterCreate(clusterObj: TagoCoreClusterCreateInfo): Promise<{
		id: string;
		token: string;
	}>;
	/**
	 * Deletes a TagoCore Cluster
	 * @param clusterID TagoCore Cluster ID
	 */
	clusterDelete(clusterID: GenericID): Promise<string>;
	/**
	 * Get Info of the Device from a Standalone TagoCore instance.
	 * @param tagoCoreID Standalone TagoCore ID
	 * @param deviceID Device ID
	 */
	standaloneDeviceInfo(tagoCoreID: GenericID, deviceID: GenericID): Promise<DeviceInfo>;
	/**
	 * Get Info of the Device from a TagoCore Cluster.
	 * @param clusterID TagoCore Cluster ID
	 * @param deviceID Device ID
	 */
	clusterDeviceInfo(clusterID: GenericID, deviceID: GenericID): Promise<DeviceInfo>;
	/**
	 * Retrieves a list with all devices from a Standalone TagoCore instance.
	 * @default
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 *   resolveBucketName: false,
	 * }
	 * @param tagoCoreID Standalone TagoCore ID
	 * @param queryObj Search query params
	 */
	standaloneDeviceList(tagoCoreID: GenericID, queryObj?: DeviceQuery): Promise<DeviceListItem[]>;
	/**
	 * Retrieves a list with all devices from a TagoCore Cluster.
	 * @default
	 * queryObj: {
	 *   page: 1,
	 *   fields: ["id", "name"],
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc",
	 *   resolveBucketName: false,
	 * }
	 * @param clusterID TagoCore Cluster ID
	 * @param queryObj Search query params
	 */
	clusterDeviceList(clusterID: GenericID, queryObj?: DeviceQuery): Promise<DeviceListItem[]>;
}
export interface AccountCreateInfo {
	/**
	 * Name of the account
	 */
	name: string;
	/**
	 * Email of the account
	 */
	email: string;
	/**
	 * Password of the account
	 */
	password: string;
	/**
	 * Password confirmation
	 */
	cpassword: string;
	/**
	 * Country of the account
	 */
	country?: string;
	/**
	 * Timezone of the account
	 */
	timezone: string;
	/**
	 * Company of the account
	 */
	company?: string;
	/**
	 * Set true if wanna receive newsletter
	 */
	newsletter?: boolean;
	developer?: boolean;
}
export interface AccountInfo extends Omit<AccountCreateInfo, "password" | "cpassword" | "country"> {
	active: boolean;
	blocked: boolean;
	id: GenericID;
	language: string;
	last_login: Date | null;
	options: {
		user_view_welcome: boolean;
		decimal_separator: string;
		thousand_separator: string;
		last_whats_new: Date | null;
	};
	phone: string | null;
	send_invoice: boolean;
	stripe_id: string | null;
	type: string;
	plan: string;
	created_at: Date;
	updated_at: Date;
	otp?: {
		authenticator: boolean;
		sms: boolean;
		email: boolean;
	};
}
export interface LoginResponse {
	type: string;
	id: GenericID;
	email: string;
	company: string;
	name: string;
	profiles: {
		account: GenericID;
		id: GenericID;
		name: GenericID;
		logo_url: string | null;
	}[];
}
export type OTPType = "sms" | "email" | "authenticator";
export interface TokenCreateInfo {
	/**
	 * Id of profile to create the token
	 */
	profile_id: GenericID;
	/**
	 * Email of the account
	 */
	email: string;
	/**
	 * Password of the account
	 */
	password: string;
	/**
	 * OTP Pin Code
	 */
	pin_code: string;
	/**
	 * OTP Type
	 */
	otp_type: OTPType;
}
declare class Account extends TagoIOModule<GenericModuleParams> {
	/**
	 * Gets all account information
	 */
	info(): Promise<AccountInfo>;
	/**
	 * Edit account
	 * @param accountObj Account data to edit
	 */
	edit(accountObj: Partial<AccountInfo>): Promise<string>;
	/**
	 * Delete account
	 */
	delete(): Promise<string>;
	/**
	 * Generates and retrieves a new token for the account
	 * @param tokenParams Token data
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static tokenCreate(tokenParams: TokenCreateInfo, region?: Regions): Promise<{
		token: GenericToken;
	}>;
	/**
	 * Retrieve list of profiles for login and do Login
	 * @param credentials Credentials
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static login(credentials: {
		email: string;
		password: string;
	}, region?: Regions): Promise<LoginResponse>;
	/**
	 * Send password recover email
	 * @param email E-mail to recovery
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static passwordRecover(email: string, region?: Regions): Promise<string>;
	/**
	 * Change account password
	 * @param password New Password
	 */
	passwordChange(password: string): Promise<string>;
	/**
	 * Create new TagoIO account
	 * @param createParams New account details
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static create(createParams: AccountCreateInfo, region?: Regions): Promise<string>;
	/**
	 *  Re-send confirmation account email
	 * @param email E-mail address
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static resendConfirmation(email: string, region?: Regions): Promise<string>;
	/**
	 * Confirm account creation
	 * @param token Confirmation token
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static confirmAccount(token: GenericToken, region?: Regions): Promise<string>;
	/**
	 * Request the PIN Code for a given OTP Type.
	 * @param credentials Credentials
	 * @param typeOTP authenticator, sms or email
	 */
	static requestLoginPINCode(credentials: {
		email: string;
		password: string;
	}, typeOTP: OTPType, region?: Regions): Promise<string>;
	/**
	 * Enable OTP for a given OTP Type.
	 * You will be requested to confirm the operation with a pin code.
	 * @param credentials Credentials
	 * @param typeOTP authenticator, sms or email
	 */
	enableOTP(credentials: {
		email: string;
		password: string;
	}, typeOTP: OTPType): Promise<string>;
	/**
	 * Enable OTP for a given OTP Type
	 * @param credentials Credentials
	 * @param typeOTP authenticator, sms or email
	 */
	disableOTP(credentials: {
		email: string;
		password: string;
	}, typeOTP: OTPType): Promise<string>;
	/**
	 * Confirm OTP enabling process for a given OTP Type
	 * @param credentials Credentials
	 * @param typeOTP authenticator, sms or email
	 */
	confirmOTP(pinCode: string, typeOTP: OTPType): Promise<string>;
	/**
	 * Accept a team member invitation to become a profile's team member.
	 *
	 * @returns Success message.
	 */
	static acceptTeamInvitation(token: string): Promise<string>;
	/**
	 * Decline a team member invitation to become a profile's team member.
	 *
	 * @returns Success message.
	 */
	static declineTeamInvitation(token: string): Promise<string>;
}
declare class AccountDeprecated extends Account {
	/**
	 * @deprecated moved to Resources.actions
	 */
	actions: Actions;
	/**
	 * @deprecated moved to Resources.analysis
	 */
	analysis: Analyses;
	/**
	 * @deprecated moved to Resources.buckets
	 */
	buckets: Buckets;
	/**
	 * @deprecated moved to Resources.files
	 */
	files: Files;
	/**
	 * @deprecated moved to Resources.dashboards
	 */
	dashboards: Dashboards;
	/**
	 * @deprecated moved to Resources.devices
	 */
	devices: Devices;
	/**
	 * @deprecated moved to Resources.dictionaries
	 */
	dictionaries: Dictionaries;
	/**
	 * @deprecated moved to Resources.billing
	 */
	billing: Billing;
	/**
	 * @deprecated moved to Resources.notifications
	 */
	notifications: Notifications;
	/**
	 * @deprecated moved to Resources.tags
	 */
	tags: Tags;
	/**
	 * @deprecated moved to Resources.paymentMethods
	 */
	paymentMethods: PaymentMethods;
	/**
	 * @deprecated moved to Resources.plan
	 */
	plan: Plan;
	/**
	 * @deprecated moved to Resources.paymentHistory
	 */
	paymentHistory: PaymentHistory;
	/**
	 * @deprecated moved to Resources.integration
	 */
	integration: Integration;
	/**
	 * @deprecated moved to Resources.template
	 */
	template: Template;
	/**
	 * @deprecated moved to Resources.accessManagement
	 */
	accessManagement: Access;
	/**
	 * @deprecated moved to Resources.run
	 */
	run: Run;
	/**
	 * @deprecated moved to Resources.serviceAuthorization
	 */
	ServiceAuthorization: ServiceAuthorization;
	/**
	 * @deprecated moved to Resources.profiles
	 */
	profiles: Profile;
	/**
	 * @deprecated moved to Resources.tagocores
	 */
	tagocores: TagoCores;
}
export declare class Resources extends TagoIOModule<GenericModuleParams> {
	constructor(params?: GenericModuleParams);
	account: Account;
	static get account(): Account;
	actions: Actions;
	static get actions(): Actions;
	analysis: Analyses;
	static get analysis(): Analyses;
	buckets: Buckets;
	static get buckets(): Buckets;
	files: Files;
	static get files(): Files;
	dashboards: Dashboards;
	static get dashboards(): Dashboards;
	devices: Devices;
	static get devices(): Devices;
	dictionaries: Dictionaries;
	static get dictionaries(): Dictionaries;
	billing: Billing;
	static get billing(): Billing;
	notifications: Notifications;
	static get notifications(): Notifications;
	tags: Tags;
	static get tags(): Tags;
	paymentMethods: PaymentMethods;
	static get paymentMethods(): PaymentMethods;
	plan: Plan;
	static get plan(): Plan;
	paymentHistory: PaymentHistory;
	static get paymentHistory(): PaymentHistory;
	integration: Integration;
	static get integration(): Integration;
	template: Template;
	static get template(): Template;
	accessManagement: Access;
	static get accessManagement(): Access;
	run: Run;
	static get run(): Run;
	serviceAuthorization: ServiceAuthorization;
	static get serviceAuthorization(): ServiceAuthorization;
	profiles: Profile;
	static get profiles(): Profile;
	tagocores: TagoCores;
	static get tagocores(): TagoCores;
}
declare class ConsoleService extends TagoIOModule<GenericModuleParams> {
	/**
	 * Log message in analysis console
	 * @param message Log message
	 * @param time Date of message
	 */
	log(message: string, time?: Date): Promise<string>;
}
export interface SMSData {
	/**
	 * Number to send SMS, Example: +5599999999999
	 */
	to: string;
	/**
	 * Message to be send
	 */
	message: string;
}
declare class SMS extends TagoIOModule<GenericModuleParams> {
	/**
	 * Send SMS to phone number
	 * @param sms SMS Object
	 */
	send(sms: SMSData): Promise<string>;
}
export interface AttachmentOptions {
	/**
	 * Archive itself
	 */
	archive: string;
	/**
	 * Name for the archive
	 */
	filename: string;
}
export interface TemplateOptions {
	/**
	 * Template name
	 *
	 * You can create an e-mail template on TagoRUN options at
	 * https://admin.tago.io/run
	 */
	name: string;
	/**
	 * Parameters to parse on Template
	 *
	 * You can use that parameter as local variable
	 * using $PARAMETER_KEY$
	 *
	 * example: params = { name: 'John' }
	 * will be $name$ on template document
	 */
	params?: {
		[key: string]: string | number;
	};
}
export interface EmailBase {
	/**
	 * E-mail address to be sent
	 *
	 * example: "myclien@tago.io"
	 */
	to: string | string[];
	/**
	 * Name of origin
	 *
	 * example: "My Run"
	 */
	from?: string;
	/**
	 * Subject of the e-mail
	 *
	 * only allow with message or html
	 */
	subject: string;
	/**
	 * Attachment for the e-mail
	 */
	attachment?: AttachmentOptions;
}
export interface EmailRawText {
	/**
	 * Message in raw text for email body
	 */
	message: string;
}
export interface EmailHTML {
	/**
	 * HTML email body
	 */
	html: string;
}
export interface EmailWithTemplate {
	/**
	 * E-mail address to be sent
	 *
	 * example: "myclien@tago.io"
	 */
	to: string | string[];
	/**
	 * Name of origin
	 *
	 * example: "My Run"
	 */
	from?: string;
	/**
	 * Attachment for the e-mail
	 */
	attachment?: AttachmentOptions;
	/**
	 * Use TagoRUN E-Mail Template
	 *
	 * Tip: If you use template together with attachment the
	 * back-end will generate a parameter called 'URL';
	 */
	template?: TemplateOptions;
}
export type EmailWithHTML = EmailBase & EmailHTML;
export type EmailWithRawText = EmailBase & EmailRawText;
declare class Email extends TagoIOModule<GenericModuleParams> {
	/**
	 * Send email
	 * @param email E-mail Object
	 *
	 * @example
	 * ```json
	 * { to: "client(at)company.com", subject: "Reports", message: "Hello client, it's your report" }
	 * { to: ["client(at)company.com", "client2(at)company.com"], subject: "Reports", message: "Hello client, it's your report" }
	 * { to: "client(at)company.com", subject: "Reports", html: "<p>Hello client, it's your report</p>" }
	 * { to: "client(at)company.com", template: { name: "my_template" } }
	 * ```
	 */
	send(email: EmailWithRawText): Promise<string>;
	send(email: EmailWithHTML): Promise<string>;
	send(email: EmailWithTemplate): Promise<string>;
}
export interface MQTTData {
	/**
	 * Topic of the message
	 */
	topic: string;
	/**
	 * Message scope
	 */
	message: string;
	/**
	 * Bucket to receive message
	 */
	bucket: GenericID;
	/**
	 * Options of the publishing message
	 */
	options?: {
		/**
		 * Default true
		 */
		retain?: boolean;
		/**
		 * Default 0
		 */
		qos?: number;
	};
}
declare class MQTT extends TagoIOModule<GenericModuleParams> {
	/**
	 * Publish MQTT
	 * @param mqtt MQTT Object
	 */
	publish(mqtt: MQTTData): Promise<string>;
}
declare class Notification extends TagoIOModule<GenericModuleParams> {
	/**
	 * Send Notification
	 * You can add ref_id from a bucket or dashboard,
	 * if it is valid it will show up a button Go To Dashboard
	 * Any account with share of the dashboard/bucket will receive too.
	 * @param notification Notification Object
	 */
	send(notification: NotificationCreate): Promise<string>;
}
export interface ArchiveFile {
	name: string;
	content: Base64;
	type: string;
}
declare class Attachment extends TagoIOModule<GenericModuleParams> {
	/**
	 *  Send Attachment
	 * @param archive Archive JSON Object
	 */
	upload(archive: ArchiveFile): Promise<string>;
}
export interface PDFResult {
	status: boolean;
	result: string;
}
export interface PDFParams {
	/**
	 * HTML as string
	 */
	html?: string;
	/**
	 * HTML on base64 format
	 */
	base64?: string;
	/**
	 * File name of pdf
	 * Without filename, it will generate base64 response
	 * With filename it will generate pdf binary
	 */
	fileName?: string;
	/**
	 * Generate pdf from URL
	 */
	url?: string;
	/**
	 * PDF Custom Options
	 */
	options?: {
		/**
		 * Display header and footer. Defaults to `false`.
		 */
		displayHeaderFooter?: boolean;
		/**
		 * HTML template for the print footer. Should use the same format as the `headerTemplate`.
		 */
		footerTemplate?: string;
		/**
		 * Paper format. If set, takes priority over `width` or `height` options. Defaults to 'Letter'.
		 */
		format?: string;
		/**
		 * HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values
		 * into them:
		 * - `'date'` formatted print date
		 * - `'title'` document title
		 * - `'url'` document location
		 * - `'pageNumber'` current page number
		 * - `'totalPages'` total pages in the document
		 */
		headerTemplate?: string;
		/**
		 * Paper height, accepts values labeled with units.
		 */
		height?: string | number;
		/**
		 * Paper orientation. Defaults to `false`.
		 */
		landscape?: boolean;
		/**
		 * Paper margins, defaults to none.
		 */
		margin?: {
			/**
			 * Top margin, accepts values labeled with units. Defaults to `0`.
			 */
			top?: string | number;
			/**
			 * Right margin, accepts values labeled with units. Defaults to `0`.
			 */
			right?: string | number;
			/**
			 * Bottom margin, accepts values labeled with units. Defaults to `0`.
			 */
			bottom?: string | number;
			/**
			 * Left margin, accepts values labeled with units. Defaults to `0`.
			 */
			left?: string | number;
		};
		/**
		 * Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means print all pages.
		 */
		pageRanges?: string;
		/**
		 * Give any CSS `@page` size declared in the page priority over what is declared in `width` and `height` or `format`
		 * options. Defaults to `false`, which will scale the content to fit the paper size.
		 */
		preferCSSPageSize?: boolean;
		/**
		 * Print background graphics. Defaults to `false`.
		 */
		printBackground?: boolean;
		/**
		 * Scale of the webpage rendering. Defaults to `1`. Scale amount must be between 0.1 and 2.
		 */
		scale?: number;
		/**
		 * Paper width, accepts values labeled with units.
		 */
		width?: string | number;
	};
}
declare class PDFService extends TagoIOModule<GenericModuleParams> {
	/**
	 * Generate a PDF from html, url or base64
	 *
	 */
	generate(params: PDFParams): Promise<PDFResult>;
}
export declare class Services extends TagoIOModule<GenericModuleParams> {
	constructor(params?: GenericModuleParams);
	console: ConsoleService;
	static get console(): ConsoleService;
	sms: SMS;
	static get sms(): SMS;
	email: Email;
	static get email(): Email;
	/** @internal @deprecated renamed to .mqtt (lowercase) */
	MQTT: MQTT;
	mqtt: MQTT;
	static get mqtt(): MQTT;
	/** @internal @deprecated renamed to .notification (lowercase)  */
	Notification: Notification;
	notification: Notification;
	static get notification(): Notification;
	/** @internal @deprecated renamed to .attachment (lowercase) */
	Attachment: Attachment;
	attachment: Attachment;
	static get attachment(): Attachment;
	/** @internal @deprecated renamed to .pdf (lowercase) */
	PDF: PDFService;
	pdf: PDFService;
	static get pdf(): PDFService;
}
export interface IDeviceParameters {
	name?: string;
	label?: string;
	type?: "text" | "dropdown" | "switch" | "number";
	default?: any;
	group?: "default" | "main" | "advanced" | "hide";
	options?: any[];
}
export interface INetworkInfo {
	id?: string;
	name?: string;
	description?: string;
	logo_url?: string;
	icon_url?: string;
	banner_url?: string;
	device_parameters?: IDeviceParameters[];
	middleware_endpoint?: string;
	payload_encoder?: string;
	payload_decoder?: string;
	public?: boolean;
	documentation_url?: string;
	serial_number?: {
		mask?: string;
		label?: string;
		image?: string;
		case?: string;
		help?: string;
		required?: boolean;
	};
	require_devices_access?: boolean;
}
export interface NetworkDeviceListQuery extends Omit<Query<DeviceItem, "name" | "visible" | "last_input" | "last_output" | "created_at" | "updated_at">, "fields"> {
}
export interface NetworkDeviceListQueryInfo extends DeviceItem {
	token: string;
}
export declare class Network extends TagoIOModule<ConnectorModuleParams> {
	/**
	 * Get information about the current network
	 */
	info(): Promise<INetworkInfo>;
	/**
	 * Get a valid token using token serie
	 * @param serieNumber
	 * @param authorization
	 */
	resolveToken(serieNumber: string, authorization?: string): Promise<GenericToken>;
	/**
	 * Retrieves a list with all devices tokens related to
	 * network and connector. Network require_devices_access
	 * param need to be true.
	 * @default
	 * queryObj: {
	 *   page: 1,
	 *   filter: {},
	 *   amount: 20,
	 *   orderBy: "name,asc"
	 * }
	 * @param connectorID Connector identification
	 * @param queryObj Search query params
	 */
	deviceList(connectorID: GenericID, queryObj?: NetworkDeviceListQuery): Promise<NetworkDeviceListQueryInfo[]>;
	/**
	 * Create or edit param for the Device in network
	 * @param deviceID Device ID
	 * @param configObj Configuration Data
	 * @param paramID Parameter ID
	 */
	deviceParamSet(deviceID: GenericID, configObj: Partial<ConfigurationParams>, paramID?: GenericID): Promise<string>;
}
export interface AuthorizationInfo {
	name: string;
	type: string;
	permission: PermissionOption;
	serie_number: string | null;
	last_authorization: Date | null;
	verification_code: string;
	expire_time: ExpireTimeOption;
	ref_id: GenericID;
	created_at: Date;
	created_by: string | null;
}
export declare class Authorization extends TagoIOModule<AuthorizationModuleParams> {
	/**
	 * Get information about the current Authorization
	 */
	info(): Promise<AuthorizationInfo>;
}
export interface UserOptions {
	decimal_separator?: string;
	thousand_separator?: string;
	date_format?: string;
	time_format?: string;
	show_last_updated_at?: string;
}
export interface RunUserCreateInfo {
	name: string;
	email: string;
	password: string;
	timezone: string;
	company?: string;
	phone?: string | null;
	language?: string;
	active: boolean;
	newsletter?: boolean;
	options?: UserOptions;
}
export interface RunUserCreate {
	user: GenericID;
}
export interface RunUserInfo extends RunUserCreateInfo {
	id: GenericID;
	created_at: Date;
	otp?: {
		authenticator: boolean;
		sms: boolean;
		email: boolean;
	};
}
export interface RunUserLoginResponse {
	token: GenericToken;
	expire_date: ExpireTimeOption;
}
export interface RunUserCredentials {
	email: string;
	password: string;
}
export interface RunUserLogin extends RunUserCredentials {
	otp_type?: OTPType;
	pin_code?: string;
}
declare class SDB extends TagoIOModule<GenericModuleParams> {
	/**
	 * Retrieves a custom parameter of a Run user.
	 * The Run user is identified by the token in the constructor.
	 * @param tagoRunURL TagoIO Run url without http
	 * @param key Identifier of the parameter
	 */
	getItem(tagoRunURL: string, key: string): Promise<any>;
	/**
	 * Creates or updates a custom parameter of a Run user.
	 * The Run user is identified by the token in the constructor.
	 * @param tagoRunURL TagoIO Run url without http
	 * @param key Identifier of the parameter
	 * @param value Value of the parameter
	 */
	setItem(tagoRunURL: string, key: string, value: string): Promise<any>;
	/**
	 * Delete a custom parameter of a Run user.
	 * The Run user is identified by the token in the constructor.
	 * @param tagoRunURL TagoIO Run url without http
	 * @param key Identifier of the parameter
	 */
	removeItem(tagoRunURL: string, key: string): Promise<any>;
}
export declare class RunUser extends TagoIOModule<GenericModuleParams> {
	/**
	 * Get Run user info
	 * @param tagoIORunURL TagoIO Run url without http
	 */
	info(tagoIORunURL: string): Promise<RunUserInfo>;
	/**
	 * Create new TagoIO Run User (Anonymous)
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param newUserObj New user data
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static create(tagoIORunURL: string, newUserObj: RunUserCreateInfo, region?: Regions): Promise<RunUserCreate>;
	/**
	 * Edit Run user info
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param userChangesObj Data to change in user
	 */
	edit(tagoIORunURL: string, userChangesObj: Partial<RunUserInfo>): Promise<string>;
	/**
	 * Delete Run user info
	 * @param tagoIORunURL TagoIO Run url without http
	 */
	delete(tagoIORunURL: string): Promise<string>;
	/**
	 * Login at TagoIO Run as user (Anonymous)
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param credentialsObj Run user credentials
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static login(tagoIORunURL: string, credentialsObj: RunUserLogin, region?: Regions): Promise<RunUserLoginResponse>;
	/**
	 * Confirm User on TagoIO Run (Anonymous)
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param token TagoIO Run user token
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static confirmUser(tagoIORunURL: string, token: GenericToken, region?: Regions): Promise<string>;
	/**
	 * Sends a password recover e-mail
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param email Run user email to recover the password
	 * @param region TagoIO Region Server [default usa-1]
	 */
	static passwordRecover(tagoIORunURL: string, email: string, region?: Regions): Promise<string>;
	/**
	 * Change password using token of the password recover.
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param password New password
	 */
	passwordChange(tagoIORunURL: string, password: string): Promise<string>;
	/**
	 * List notifications.
	 * @param tagoIORunURL TagoIO Run url without http
	 */
	notificationList(tagoIORunURL: string, queryObj?: NotificationQuery): Promise<NotificationInfo[]>;
	/**
	 * Mark notification as read
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param notificationIDs array of notification ids or a single id
	 */
	notificationMarkRead(tagoIORunURL: string, notificationIDs: GenericID | GenericID[]): Promise<string>;
	/**
	 * Mark notification as unread
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param notificationIDs array of notification ids or a single id
	 */
	notificationMarkUnread(tagoIORunURL: string, notificationIDs: GenericID | GenericID[]): Promise<string>;
	/**
	 * Mark all notifications as read
	 * @param tagoIORunURL TagoIO Run url without http
	 */
	notificationMarkAllRead(tagoIORunURL: string): Promise<string>;
	/**
	 * Trigger notification button
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param notificationID TagoIO Run notification id
	 * @param buttonID Notification button id
	 */
	notificationButton(tagoIORunURL: string, notificationID: GenericID, buttonID: GenericID): Promise<any>;
	/**
	 * Delete notification
	 * @param tagoIORunURL TagoIO Run url without http
	 * @param notificationID TagoIO Run notification id
	 */
	notificationDelete(tagoIORunURL: string, notificationID: GenericID): Promise<string>;
	/**
	 * Request the PIN Code for a given OTP Type.
	 * @param credentials Credentials
	 * @param typeOTP authenticator, sms or email
	 */
	static requestLoginPINCode(tagoIORunURL: string, credentials: RunUserCredentials, typeOTP: OTPType): Promise<string>;
	/**
	 * Enable OTP for a given OTP Type.
	 * You will be requested to confirm the operation with a pin code.
	 * @param credentials Credentials
	 * @param typeOTP authenticator, sms or email
	 */
	enableOTP(tagoIORunURL: string, credentials: RunUserCredentials, typeOTP: OTPType): Promise<string>;
	/**
	 * Enable OTP for a given OTP Type
	 * @param credentials Credentials
	 * @param typeOTP authenticator, sms or email
	 */
	disableOTP(tagoIORunURL: string, credentials: RunUserCredentials, typeOTP: OTPType): Promise<string>;
	/**
	 * Confirm OTP enabling process for a given OTP Type
	 * @param credentials Credentials
	 * @param typeOTP authenticator, sms or email
	 */
	confirmOTP(tagoIORunURL: string, pinCode: string, typeOTP: OTPType): Promise<string>;
	SDB: SDB;
}
export interface IDictionaryModuleParams extends GenericModuleParams {
	token: string;
	region?: Regions;
	language?: string;
	options?: object;
}
export interface IDictionaryModuleParamsAnonymous extends GenericModuleParams {
	runURL: string;
	region?: Regions;
	language?: string;
	options?: object;
}
export interface IParsedExpression {
	dictionary: string;
	key: string;
	params?: string[];
}
export interface IResolveExpressionParams {
	language: string;
	expression: IParsedExpression;
}
export interface IApplyToStringOptions {
	language?: string;
}
export declare class Dictionary extends TagoIOModule<IDictionaryModuleParams> {
	language: string;
	runURL?: string;
	constructor(params: IDictionaryModuleParams);
	constructor(params: IDictionaryModuleParamsAnonymous);
	/**
	 * Get the language data for a dictionary.
	 *
	 * @param language Language.
	 * @param dictionary ID or Slug.
	 * @param runURL URL for the Run to make anonymous request.
	 */
	getLanguagesData(dictionary: string, language?: string): Promise<LanguageData>;
	/**
	 * Get value from a key in a specific dictionary for a language.
	 *
	 * @param language Name of the language (locale code).
	 * @param dictionary Name of the dictionary.
	 * @param key Name of the key.
	 *
	 * @example
	 * ```
	 * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
	 * const value = dictionary.getValueFromKey("en-US", "TEST", "OK_BUTTON_LABEL");
	 * ```
	 */
	getValueFromKey(language: string, dictionary: string, key: string): Promise<string>;
	/**
	 * Parse an expression and extract the names of the dictionary, the key, and
	 * any arguments that are passed in the expression.
	 *
	 * Returns `null` if the value passed is not parseable by the RegEx.
	 *
	 * @param expression String expression.
	 *
	 * @example
	 * ```
	 * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
	 * const value = dictionary.parseExpression("#TAGORUN.WELCOME_TEXT,Hello");
	 * ```
	 */
	parseExpression(expression: string): IParsedExpression;
	/**
	 * Resolve an expression in a language, replacing the parameters in the
	 * dictionary value with the arguments passed in the expression.
	 *
	 * @param resolveParams Object with the language and the parsed expression (from `parseExpression`).
	 *
	 * @example
	 * ```
	 * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
	 * const value = dictionary.resolveExpression({
	 *   language: "en-US",
	 *   expression: {
	 *     dictionary: "TEST",
	 *     key: "SOME_KEY",
	 *     params: [
	 *       "first parameter",
	 *     ],
	 *   },
	 * });
	 * ```
	 */
	resolveExpression(resolveParams: IResolveExpressionParams): Promise<string>;
	/**
	 * Get all (and only) the expressions in a string and their parameters if applicable,
	 * ignoring normal words and phrases.
	 *
	 * @param rawString String with words and/or expressions.
	 *
	 * @example
	 * ```
	 * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
	 * const expressions = dictionary.getExpressionsFromString("Words are ignored #TEST.DICT_KEY#");
	 * ```
	 */
	getExpressionsFromString(rawString: string): Promise<IParsedExpression[]>;
	/**
	 * Apply the dictionary over a string, parsing the expressions in the string and
	 * replacing them with the values found for the respective keys inside the dictionary
	 * for a language.
	 *
	 * Always returns a string. Return the translated string if there are dictionary expressions,
	 * the raw string with no changes if there are no expressions, and an empty string if `rawString`
	 * is undefined.
	 *
	 * @param rawString String with words and/or expressions.
	 * @param options Object containing options for the dictionary, including the language.
	 *
	 * @example
	 * ```
	 * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
	 * const result = dictionary.applyToString("Words are ignored #TEST.DICT_KEY#");
	 * ```
	 */
	applyToString(rawString: string, options?: IApplyToStringOptions): Promise<string>;
}
export declare class Migration extends TagoIOModule<any> {
	static convertImagerMarkerData(widget: any, widgetData: any): any[];
	/**
	 * Returns if the widget type is supported by migration
	 */
	static hasMigrate(widget: any): boolean;
	/**
	 * Check if a widget structure is old or not,
	 * based on his type
	 */
	static isOldStructure(widget: any): boolean;
	/**
	 * Convert widget old structure to new one
	 */
	static convertWidget(widget: any): WidgetInfo;
}

export {
	AccountDeprecated as Account,
};

export {};
